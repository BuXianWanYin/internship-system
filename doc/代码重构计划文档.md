# 代码重构计划文档

## 文档说明
本文档列出了代码库中需要重构的重复模式和可以优化的地方，按照优先级和影响范围进行分类。

---

## 一、高优先级重构项（影响范围大、重复度高）

### 1.1 实体默认值设置工具类

**问题描述：**
在多个Service实现类中，存在大量重复的实体默认值设置代码：
- `entity.setDeleteFlag(DeleteFlag.NORMAL.getCode())` - 出现33次
- `if (entity.getStatus() == null) { entity.setStatus(...) }` - 出现15次

**影响文件：**
- `EnterpriseServiceImpl.java` (3处)
- `ClassServiceImpl.java` (1处)
- `UserServiceImpl.java` (2处)
- `TeacherServiceImpl.java` (3处)
- `StudentServiceImpl.java` (1处)
- `AttendanceServiceImpl.java` (4处)
- `InternshipLogServiceImpl.java` (1处)
- `InternshipAchievementServiceImpl.java` (1处)
- `InternshipFeedbackServiceImpl.java` (1处)
- `InternshipWeeklyReportServiceImpl.java` (1处)
- `InterviewServiceImpl.java` (1处)
- `InternshipApplyServiceImpl.java` (3处)
- `InternshipPlanServiceImpl.java` (1处)
- `InternshipPostServiceImpl.java` (1处)
- `SchoolAdminServiceImpl.java` (1处)
- `MajorServiceImpl.java` (1处)
- `SystemConfigServiceImpl.java` (1处)
- `EnterpriseSchoolCooperationServiceImpl.java` (1处)
- `CollegeServiceImpl.java` (1处)
- `SemesterServiceImpl.java` (1处)
- `EnterpriseMentorServiceImpl.java` (1处)
- `SchoolServiceImpl.java` (1处)
- `EnterpriseRegisterSchoolServiceImpl.java` (1处)

**重构方案：**
创建 `EntityDefaultValueUtil` 工具类，提供以下方法：
```java
public static <T> void setDefaultValues(T entity, Integer defaultStatus) {
    // 设置deleteFlag
    // 如果status为null，设置默认status
}
```

**预期收益：**
- 减少代码重复：33处 → 统一工具方法调用
- 提高一致性：确保所有实体都使用相同的默认值设置逻辑
- 易于维护：修改默认值逻辑时只需修改一处

---

### 1.2 查询Wrapper的DeleteFlag过滤工具方法

**问题描述：**
在查询时，大量使用 `.eq(Entity::getDeleteFlag, DeleteFlag.NORMAL.getCode())` 来过滤已删除的记录，出现204次。

**影响文件：**
- `DataPermissionUtil.java` (17处)
- `EnterpriseServiceImpl.java` (7处)
- `ClassServiceImpl.java` (12处)
- `UserServiceImpl.java` (35处)
- `TeacherServiceImpl.java` (5处)
- `StudentServiceImpl.java` (6处)
- `AttendanceServiceImpl.java` (7处)
- `InternshipLogServiceImpl.java` (4处)
- `InternshipAchievementServiceImpl.java` (1处)
- `InternshipFeedbackServiceImpl.java` (1处)
- `InternshipWeeklyReportServiceImpl.java` (1处)
- `InterviewServiceImpl.java` (1处)
- `InternshipApplyServiceImpl.java` (2处)
- `InternshipPlanServiceImpl.java` (1处)
- `InternshipPostServiceImpl.java` (1处)
- `MajorServiceImpl.java` (1处)
- `SystemConfigServiceImpl.java` (1处)
- `CollegeServiceImpl.java` (1处)
- `SemesterServiceImpl.java` (1处)
- `EnterpriseMentorServiceImpl.java` (1处)
- `SchoolServiceImpl.java` (1处)
- 以及其他多个文件

**重构方案：**
在 `EntityValidationUtil` 或创建新的 `QueryWrapperUtil` 工具类，提供以下方法：
```java
public static <T> LambdaQueryWrapper<T> notDeleted(LambdaQueryWrapper<T> wrapper) {
    return wrapper.eq(Entity::getDeleteFlag, DeleteFlag.NORMAL.getCode());
}

// 或者作为wrapper的扩展方法
public static <T> LambdaQueryWrapper<T> buildNotDeletedWrapper() {
    return new LambdaQueryWrapper<T>()
        .eq(Entity::getDeleteFlag, DeleteFlag.NORMAL.getCode());
}
```

**预期收益：**
- 减少代码重复：204处 → 统一工具方法调用
- 提高可读性：`notDeleted(wrapper)` 比 `.eq(DeleteFlag.NORMAL.getCode())` 更语义化
- 易于维护：如果需要修改删除标志的逻辑，只需修改一处

---

### 1.3 字符串非空验证工具方法

**问题描述：**
大量使用 `if (!StringUtils.hasText(...))` 进行字符串非空验证，出现77次。

**影响文件：**
- `EnterpriseServiceImpl.java` (7处)
- `ClassServiceImpl.java` (3处)
- `UserServiceImpl.java` (6处)
- `TeacherServiceImpl.java` (5处)
- `StudentServiceImpl.java` (4处)
- `AttendanceServiceImpl.java` (2处)
- `InternshipLogServiceImpl.java` (2处)
- `InternshipAchievementServiceImpl.java` (2处)
- `InternshipFeedbackServiceImpl.java` (3处)
- `InternshipWeeklyReportServiceImpl.java` (3处)
- `InterviewServiceImpl.java` (3处)
- `InternshipApplyServiceImpl.java` (7处)
- `InternshipPlanServiceImpl.java` (2处)
- `InternshipPostServiceImpl.java` (3处)
- `MajorServiceImpl.java` (2处)
- `SystemConfigServiceImpl.java` (2处)
- `CollegeServiceImpl.java` (2处)
- `SemesterServiceImpl.java` (1处)
- `EnterpriseMentorServiceImpl.java` (2处)
- `SchoolServiceImpl.java` (2处)
- `AuthServiceImpl.java` (2处)
- `PermissionServiceImpl.java` (1处)
- `RoleServiceImpl.java` (1处)
- `DataPermissionUtil.java` (1处)

**重构方案：**
在 `EntityValidationUtil` 中扩展方法：
```java
public static void validateStringNotBlank(String value, String fieldName) {
    if (!StringUtils.hasText(value)) {
        throw new BusinessException(fieldName + "不能为空");
    }
}
```

**预期收益：**
- 减少代码重复：77处 → 统一工具方法调用
- 统一错误消息格式
- 提高代码可读性

---

### 1.4 唯一性检查工具方法

**问题描述：**
在多个Service中，存在重复的唯一性检查模式：
```java
LambdaQueryWrapper<Entity> wrapper = new LambdaQueryWrapper<>();
wrapper.eq(Entity::getCode, code)
       .eq(Entity::getDeleteFlag, DeleteFlag.NORMAL.getCode());
Entity existEntity = this.getOne(wrapper);
if (existEntity != null) {
    throw new BusinessException("代码已存在");
}
```

**影响文件：**
- `EnterpriseServiceImpl.java` - 企业代码、统一社会信用代码检查
- `SchoolServiceImpl.java` - 学校代码检查
- `ClassServiceImpl.java` - 班级代码检查
- `CollegeServiceImpl.java` - 学院代码检查
- `MajorServiceImpl.java` - 专业代码检查
- `InternshipPostServiceImpl.java` - 岗位编号检查
- `InternshipPlanServiceImpl.java` - 计划编号检查
- `UserServiceImpl.java` - 用户名检查
- `StudentServiceImpl.java` - 学号检查
- `TeacherServiceImpl.java` - 教师编号检查

**重构方案：**
创建 `UniquenessValidationUtil` 工具类：
```java
public static <T> void validateUnique(IService<T> service, 
                                      Function<T, Object> fieldGetter,
                                      Object fieldValue,
                                      String entityName,
                                      String fieldName) {
    LambdaQueryWrapper<T> wrapper = new LambdaQueryWrapper<>();
    // 使用反射设置字段条件
    wrapper.eq(fieldGetter, fieldValue)
           .eq(Entity::getDeleteFlag, DeleteFlag.NORMAL.getCode());
    T existEntity = service.getOne(wrapper);
    if (existEntity != null) {
        throw new BusinessException(fieldName + "已存在");
    }
}
```

**预期收益：**
- 减少代码重复：约20-30处 → 统一工具方法调用
- 统一唯一性检查逻辑
- 提高代码可维护性

---

## 二、中优先级重构项（影响范围中等）

### 2.1 集合非空检查统一

**问题描述：**
虽然已经创建了 `EntityValidationUtil.isNotEmpty()` 和 `isEmpty()` 方法，但仍有大量地方使用原始检查方式：
- `list != null && !list.isEmpty()` - 出现约119次
- `list == null || list.isEmpty()` - 出现约50次

**影响文件：**
- `DataPermissionUtil.java` (10处)
- `UserServiceImpl.java` (约40处)
- `StudentServiceImpl.java` (约10处)
- `InternshipApplyServiceImpl.java` (约15处)
- `InternshipLogServiceImpl.java` (约8处)
- `InternshipAchievementServiceImpl.java` (约6处)
- `InternshipWeeklyReportServiceImpl.java` (约6处)
- `AttendanceServiceImpl.java` (约8处)
- `InternshipFeedbackServiceImpl.java` (约6处)
- 以及其他多个文件

**重构方案：**
继续替换所有集合非空检查为 `EntityValidationUtil.isNotEmpty()` 和 `isEmpty()`。

**预期收益：**
- 减少代码重复：约169处 → 统一工具方法调用
- 提高代码一致性

---

### 2.2 日期范围验证工具方法

**问题描述：**
在多个地方进行日期范围验证：
- `startDate.isAfter(endDate)` - 开始日期不能晚于结束日期
- `date.isBefore(minDate)` - 日期不能早于最小日期
- `date.isAfter(maxDate)` - 日期不能晚于最大日期

**影响文件：**
- `InternshipPlanServiceImpl.java` - 计划日期范围验证
- `InternshipApplyServiceImpl.java` - 申请日期范围验证（多处）
- `SemesterServiceImpl.java` - 学期日期范围验证
- `ClassServiceImpl.java` - 分享码过期时间验证
- `AttendanceServiceImpl.java` - 考勤时间验证

**重构方案：**
创建 `DateValidationUtil` 工具类：
```java
public static void validateDateRange(LocalDate startDate, LocalDate endDate, String entityName) {
    if (startDate != null && endDate != null && startDate.isAfter(endDate)) {
        throw new BusinessException(entityName + "开始日期不能晚于结束日期");
    }
}

public static void validateDateInRange(LocalDate date, LocalDate minDate, LocalDate maxDate, String fieldName) {
    if (date != null) {
        if (minDate != null && date.isBefore(minDate)) {
            throw new BusinessException(fieldName + "不能早于" + minDate);
        }
        if (maxDate != null && date.isAfter(maxDate)) {
            throw new BusinessException(fieldName + "不能晚于" + maxDate);
        }
    }
}
```

**预期收益：**
- 减少代码重复：约12处 → 统一工具方法调用
- 统一日期验证逻辑和错误消息

---

### 2.3 状态检查模式优化

**问题描述：**
存在以下状态检查模式：
- `status == null || status.equals(disabledStatus)` - 检查是否禁用
- `status == null || (!status.equals(status1) && !status.equals(status2))` - 检查状态是否不在允许列表中

**影响文件：**
- `UserDetailsServiceImpl.java` - 用户状态检查
- `InterviewServiceImpl.java` - 面试状态检查（3处）
- `InternshipApplyServiceImpl.java` - 申请状态检查

**重构方案：**
在 `EntityValidationUtil` 中扩展方法：
```java
public static <T> void validateStatusNotEquals(T entity, Integer forbiddenStatus, String entityName, String errorMessage) {
    // 检查状态是否不等于指定值
}

public static <T> void validateStatusIn(T entity, List<Integer> allowedStatuses, String entityName, String errorMessage) {
    // 检查状态是否在允许列表中
}
```

**预期收益：**
- 减少代码重复：约6处 → 统一工具方法调用
- 提高代码可读性

---

## 三、低优先级重构项（可选优化）

### 3.1 Wrapper.in() 条件构建优化

**问题描述：**
在使用 `wrapper.in()` 时，经常需要先检查集合是否为空：
```java
if (EntityValidationUtil.isNotEmpty(ids)) {
    wrapper.in(Entity::getId, ids);
}
```

**影响文件：**
- 约56处使用 `.in()` 的地方

**重构方案：**
创建工具方法：
```java
public static <T, R> LambdaQueryWrapper<T> inIfNotEmpty(LambdaQueryWrapper<T> wrapper, 
                                                         SFunction<T, R> column, 
                                                         Collection<R> values) {
    if (EntityValidationUtil.isNotEmpty(values)) {
        wrapper.in(column, values);
    }
    return wrapper;
}
```

**预期收益：**
- 简化代码：减少if判断
- 提高代码可读性

---

### 3.2 关联字段填充模式提取

**问题描述：**
多个Service中有 `fillXxxRelatedFields()` 方法，用于填充关联字段。这些方法有相似的模式，但具体实现差异较大。

**影响文件：**
- `InternshipLogServiceImpl.java` - `fillLogRelatedFields()`
- `InternshipAchievementServiceImpl.java` - `fillAchievementRelatedFields()`
- `InternshipWeeklyReportServiceImpl.java` - `fillReportRelatedFields()`
- `AttendanceServiceImpl.java` - `fillAttendanceRelatedFields()`
- `InternshipFeedbackServiceImpl.java` - `fillFeedbackRelatedFields()`
- `InterviewServiceImpl.java` - `fillInterviewRelatedFields()`
- `InternshipApplyServiceImpl.java` - `fillApplyRelatedFields()`
- `InternshipPostServiceImpl.java` - `fillPostRelatedFields()`
- `InternshipPlanServiceImpl.java` - `fillPlanRelatedFields()`

**重构方案：**
由于每个实体的关联字段不同，建议保持现状，但可以考虑：
1. 统一方法命名规范
2. 提取通用的填充逻辑（如填充用户信息、学生信息等）

**预期收益：**
- 提高代码一致性
- 便于理解和维护

---

## 四、重构执行计划

### 阶段一：高优先级重构（预计2-3小时）
1. ✅ 创建 `EntityDefaultValueUtil` 工具类
2. ✅ 创建查询Wrapper工具方法（DeleteFlag过滤）
3. ✅ 扩展 `EntityValidationUtil` 添加字符串验证方法
4. ✅ 创建 `UniquenessValidationUtil` 工具类
5. ✅ 替换所有相关代码

### 阶段二：中优先级重构（预计1-2小时）
1. ✅ 继续替换集合非空检查
2. ✅ 创建 `DateValidationUtil` 工具类
3. ✅ 扩展 `EntityValidationUtil` 添加状态检查方法
4. ✅ 替换所有相关代码

### 阶段三：低优先级重构（可选，预计1小时）
1. 创建Wrapper条件构建工具方法
2. 优化关联字段填充模式（如需要）

---

## 五、重构注意事项

1. **向后兼容性**：所有重构必须保持API的向后兼容性
2. **测试覆盖**：重构后需要运行所有测试用例，确保功能正常
3. **代码审查**：重构后的代码需要经过代码审查
4. **文档更新**：更新相关开发文档，说明新的工具类使用方法
5. **渐进式重构**：建议分阶段进行，每个阶段完成后进行测试

---

## 六、预期收益总结

| 重构项 | 重复次数 | 预期减少代码行数 | 优先级 |
|--------|---------|----------------|--------|
| 实体默认值设置 | 48处 | ~200行 | 高 |
| DeleteFlag过滤 | 204处 | ~400行 | 高 |
| 字符串验证 | 77处 | ~150行 | 高 |
| 唯一性检查 | ~25处 | ~100行 | 高 |
| 集合非空检查 | ~169处 | ~200行 | 中 |
| 日期范围验证 | ~12处 | ~50行 | 中 |
| 状态检查优化 | ~6处 | ~30行 | 中 |
| Wrapper.in优化 | ~56处 | ~50行 | 低 |

**总计：** 预计减少约1180行重复代码，提高代码可维护性和一致性。

---

## 七、工具类设计规范

### 7.1 工具类命名规范
- 工具类以 `Util` 结尾
- 工具类应该是 `final` 类，包含私有构造函数
- 所有方法应该是 `static` 方法

### 7.2 方法设计规范
- 方法应该专注于单一职责
- 方法参数应该清晰明确
- 方法应该提供有意义的错误消息
- 方法应该支持泛型以提高复用性

### 7.3 异常处理规范
- 验证失败应该抛出 `BusinessException`
- 错误消息应该清晰明确，包含字段名称和原因

---

## 八、后续维护建议

1. **代码审查检查点**：在代码审查时，检查是否使用了新的工具类
2. **开发规范更新**：更新开发规范文档，要求使用新的工具类
3. **定期重构**：定期检查代码库，发现新的重复模式并及时重构
4. **工具类文档**：为每个工具类编写详细的JavaDoc文档

---

**文档版本：** v1.0  
**创建日期：** 2024-12-19  
**最后更新：** 2024-12-19

