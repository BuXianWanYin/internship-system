# 用户管理角色化表单与入学年份筛选优化方案

## 一、需求概述

### 1.1 核心需求

1. **用户管理页面添加用户时，根据角色显示不同的表单字段**
   - 学生角色：需要设置学校、学院、班级、学号、入学年份
   - 学校管理员角色：学校默认绑定当前用户的学校，不允许修改
   - 学院负责人角色：学校、学院默认绑定，不允许修改
   - 班主任角色：学校、学院默认绑定，不允许修改；班级可选（可管理多个班级）
   - 其他角色：根据角色特性显示相应字段

2. **角色选择改为单选**
   - 添加用户时，角色只能选择一个
   - 编辑用户时，可以修改角色（但需要权限控制）

3. **教师管理页面职称改为下拉框**
   - 将职称输入框改为下拉选择框
   - 提供常用职称选项：教授、副教授、讲师、助教、暂无职称等

4. **入学年份筛选优化**
   - 需要提供多个实现方案
   - 对比各方案的优缺点
   - 选择最优方案并实现

## 二、详细需求分析

### 2.1 用户管理页面角色化表单需求

#### 2.1.1 角色与表单字段映射关系

| 角色 | 必填字段 | 默认值/禁用规则 | 说明 |
|------|---------|----------------|------|
| **学生 (ROLE_STUDENT)** | 学校、学院、专业、班级、学号、入学年份 | 无默认值，全部可选 | 需要完整的组织架构信息 |
| **学校管理员 (ROLE_SCHOOL_ADMIN)** | 学校 | 默认当前用户的学校，禁用 | 只能添加自己学校的管理员 |
| **学院负责人 (ROLE_COLLEGE_LEADER)** | 学校、学院 | 默认当前用户的学校、学院，禁用 | 只能添加自己学院的负责人 |
| **班主任 (ROLE_CLASS_TEACHER)** | 学校、学院、班级（可选多个） | 默认当前用户的学校、学院，禁用；班级可选 | 可以管理多个班级 |
| **企业管理员 (ROLE_ENTERPRISE_ADMIN)** | 企业 | 无默认值，可选 | 需要选择或创建企业 |
| **企业导师 (ROLE_ENTERPRISE_MENTOR)** | 企业 | 无默认值，可选 | 需要选择企业 |

#### 2.1.2 权限控制规则

1. **系统管理员**：
   - 可以添加所有角色
   - 所有字段都可以选择，无默认值限制

2. **学校管理员**：
   - 可以添加：学校管理员、学院负责人、班主任、学生
   - 不能添加：系统管理员、企业相关角色
   - 学校字段默认绑定，不允许修改

3. **学院负责人**：
   - 可以添加：班主任、学生
   - 不能添加：系统管理员、学校管理员、学院负责人、企业相关角色
   - 学校、学院字段默认绑定，不允许修改

4. **班主任**：
   - 可以添加：学生
   - 不能添加：其他所有角色
   - 学校、学院字段默认绑定，不允许修改
   - 班级字段可选，可以选择自己管理的班级

### 2.2 角色选择改为单选

#### 2.2.1 当前问题
- 当前角色选择支持多选（`multiple`）
- 但实际业务中，一个用户通常只有一个主要角色
- 多选可能导致业务逻辑混乱

#### 2.2.2 修改方案
- 将角色选择改为单选（移除 `multiple` 属性）
- 添加用户时：只能选择一个角色
- 编辑用户时：可以修改角色（但需要权限验证）
- 根据选择的角色，动态显示/隐藏相应的表单字段

### 2.3 教师管理页面职称下拉框

#### 2.3.1 当前实现
- 职称使用文本输入框
- 用户需要手动输入，容易出现不一致（如"教授"、"正教授"、"Prof"等）

#### 2.3.2 优化方案
- 改为下拉选择框
- 提供标准职称选项：
  - 教授
  - 副教授
  - 讲师
  - 助教
  - 研究员
  - 副研究员
  - 助理研究员
  - 其他（可选，允许自定义输入）

### 2.4 入学年份筛选优化方案

#### 2.4.1 问题分析
当前入学年份筛选使用固定年份范围（最近10年），但实际可能存在以下问题：
1. 系统中可能没有某些年份的学生数据
2. 某些年份可能已经不再使用
3. 固定范围可能不够灵活

#### 2.4.2 方案对比

##### 方案一：基于现有学生数据的动态生成（推荐）

**实现方式**：
- 从数据库中查询所有已存在学生的入学年份
- 去重后按降序排列
- 动态生成下拉框选项

**优点**：
- 只显示实际存在的年份，避免无效选项
- 自动适应数据变化
- 无需额外维护
- 实现简单

**缺点**：
- 如果系统中没有学生数据，下拉框为空
- 新学年开始时，需要先有学生数据才能筛选

**适用场景**：
- 系统已有学生数据
- 希望筛选选项与实际数据保持一致

**实现代码示例**：
```javascript
// 前端：从学生列表API获取入学年份
const loadEnrollmentYears = async () => {
  try {
    const res = await studentApi.getEnrollmentYears()
    if (res.code === 200) {
      enrollmentYearOptions.value = res.data || []
    }
  } catch (error) {
    console.error('加载入学年份失败:', error)
  }
}

// 后端：新增API接口
@GetMapping("/enrollment-years")
public Result<List<Integer>> getEnrollmentYears() {
    List<Integer> years = studentService.getDistinctEnrollmentYears();
    return Result.success(years);
}
```

##### 方案二：入学年份管理功能

**实现方式**：
- 创建入学年份管理模块
- 管理员可以手动添加/删除入学年份
- 筛选时从管理模块获取年份列表

**优点**：
- 可以提前配置未来年份
- 可以删除不再使用的年份
- 管理灵活，可控性强

**缺点**：
- 需要额外的管理功能
- 增加系统复杂度
- 需要管理员手动维护
- 开发工作量大

**适用场景**：
- 需要提前配置未来年份
- 需要严格控制可用年份
- 有专门的管理人员维护

**实现代码示例**：
```sql
-- 创建入学年份管理表
CREATE TABLE enrollment_year_config (
    year_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    year_value INT NOT NULL UNIQUE COMMENT '年份值',
    year_name VARCHAR(50) COMMENT '年份名称（如：2021级）',
    status TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    sort_order INT DEFAULT 0 COMMENT '排序',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

##### 方案三：固定范围 + 动态补充

**实现方式**：
- 基础范围：当前年份往前10年，往后2年
- 动态补充：从现有学生数据中获取不在基础范围内的年份
- 合并去重后显示

**优点**：
- 兼顾固定范围和动态数据
- 新学年开始时就有选项
- 历史数据也能筛选

**缺点**：
- 实现相对复杂
- 需要合并逻辑

**适用场景**：
- 需要兼顾新学年和历史数据
- 希望既有固定范围又有灵活性

**实现代码示例**：
```javascript
const enrollmentYearOptions = computed(() => {
  const currentYear = new Date().getFullYear()
  const fixedYears = []
  // 当前年份往前10年，往后2年
  for (let i = currentYear + 2; i >= currentYear - 10; i--) {
    fixedYears.push(i)
  }
  
  // 合并动态年份
  const dynamicYears = enrollmentYearsFromDB.value || []
  const allYears = [...new Set([...fixedYears, ...dynamicYears])]
  return allYears.sort((a, b) => b - a) // 降序排列
})
```

##### 方案四：配置化年份范围

**实现方式**：
- 在系统配置表中设置年份范围参数
- 如：`enrollment_year_start` = 2000, `enrollment_year_end` = 2030
- 根据配置生成年份列表

**优点**：
- 配置灵活，可随时调整
- 无需代码修改
- 实现简单

**缺点**：
- 需要系统配置功能支持
- 可能包含大量无效年份

**适用场景**：
- 已有系统配置模块
- 年份范围相对固定

#### 2.4.3 方案推荐

**推荐方案：方案一（基于现有学生数据的动态生成）**

**推荐理由**：
1. **实现简单**：只需一个查询接口，前端动态渲染
2. **数据准确**：只显示实际存在的年份，避免无效筛选
3. **自动适应**：随着数据变化自动更新
4. **用户体验好**：选项精简，不会出现大量无效选项
5. **维护成本低**：无需额外管理功能

**补充建议**：
- 如果系统中没有学生数据，可以显示提示信息："暂无学生数据"
- 可以考虑添加"全部"选项，不限制年份
- 对于新学年，可以在添加第一个学生时自动包含该年份

#### 2.4.4 新学年开始的处理方案

**问题场景**：
- 新学年开始时（如2025年9月），系统中还没有2025年入学的学生数据
- 如果使用方案一（纯动态生成），下拉框中不会显示2025年
- 管理员需要添加2025年入学的学生时，无法选择年份

**解决方案对比**：

##### 方案A：方案一 + 前端兜底（推荐）

**实现方式**：
- 后端：只返回数据库中实际存在的年份
- 前端：如果返回的年份列表为空，或者不包含当前年份，自动补充：
  - 当前年份（如2025）
  - 当前年份-1（如2024）
  - 当前年份-2（如2023）
  - 当前年份+1（如2026，可选）

**优点**：
- 保持方案一的优势（数据准确、自动适应）
- 新学年开始时，前端自动显示当前年份
- 实现简单，只需前端逻辑调整

**缺点**：
- 如果数据库中没有数据，会显示固定年份，可能包含无效选项

**实现代码**：
```javascript
// 加载入学年份
const loadEnrollmentYears = async () => {
  try {
    const res = await studentApi.getEnrollmentYears()
    const currentYear = new Date().getFullYear()
    
    if (res.code === 200) {
      let years = res.data || []
      
      // 如果数据库中没有年份，或者不包含当前年份，添加默认年份
      if (years.length === 0 || !years.includes(currentYear)) {
        const defaultYears = [currentYear, currentYear - 1, currentYear - 2]
        // 合并并去重
        years = [...new Set([...defaultYears, ...years])].sort((a, b) => b - a)
      }
      
      enrollmentYearOptions.value = years
    }
  } catch (error) {
    console.error('加载入学年份失败:', error)
    // 失败时使用固定范围
    const currentYear = new Date().getFullYear()
    enrollmentYearOptions.value = []
    for (let i = currentYear; i >= currentYear - 10; i--) {
      enrollmentYearOptions.value.push(i)
    }
  }
}
```

##### 方案B：方案三（固定范围 + 动态补充）

**实现方式**：
- 基础范围：当前年份往前10年，往后2年（固定显示）
- 动态补充：从数据库查询实际存在的年份
- 合并去重后显示

**优点**：
- 新学年开始时就有选项（当前年份+2年）
- 历史数据也能筛选
- 兼顾固定范围和动态数据

**缺点**：
- 实现相对复杂
- 可能包含无效年份（如未来年份）

**实现代码**：
```javascript
const enrollmentYearOptions = computed(() => {
  const currentYear = new Date().getFullYear()
  const fixedYears = []
  // 当前年份往前10年，往后2年
  for (let i = currentYear + 2; i >= currentYear - 10; i--) {
    fixedYears.push(i)
  }
  
  // 合并动态年份
  const dynamicYears = enrollmentYearsFromDB.value || []
  const allYears = [...new Set([...fixedYears, ...dynamicYears])]
  return allYears.sort((a, b) => b - a) // 降序排列
})
```

##### 方案C：添加学生时允许输入年份

**实现方式**：
- 下拉框支持可搜索（`filterable`）
- 允许创建新选项（`allow-create`）
- 如果选择的年份不在列表中，自动添加到选项

**优点**：
- 灵活性最高
- 新学年开始时，管理员可以直接输入年份

**缺点**：
- 可能输入无效年份
- 需要验证年份的合理性（如不能是未来10年）

**实现代码**：
```vue
<el-form-item label="入学年份" prop="enrollmentYear">
  <el-select
    v-model="formData.enrollmentYear"
    placeholder="请选择或输入入学年份"
    style="width: 100%"
    filterable
    allow-create
    default-first-option
  >
    <el-option
      v-for="year in enrollmentYearOptions"
      :key="year"
      :label="`${year}年`"
      :value="year"
    />
  </el-select>
</el-form-item>
```

**推荐方案：方案A（方案一 + 前端兜底）**

**推荐理由**：
1. **保持方案一的优势**：数据准确、自动适应
2. **解决新学年问题**：前端自动补充当前年份
3. **实现简单**：只需前端逻辑调整
4. **用户体验好**：新学年开始时，下拉框自动显示当前年份

**具体实现逻辑**：
1. 后端API返回数据库中实际存在的年份
2. 前端检查返回的年份列表：
   - 如果为空，添加当前年份、当前年份-1、当前年份-2
   - 如果不包含当前年份，添加当前年份
   - 如果包含当前年份，直接使用
3. 添加学生成功后，重新加载年份列表，新年份会自动出现

**新学年开始流程**：
1. **9月新学年开始**：系统中还没有新学年学生数据
2. **管理员添加学生**：
   - 打开添加学生表单
   - 入学年份下拉框自动显示当前年份（2025年）
   - 选择2025年，填写其他信息，提交
3. **添加成功后**：
   - 数据库中有了2025年的学生数据
   - 下次加载年份列表时，2025年会自动出现在下拉框中
4. **后续添加**：
   - 其他管理员添加学生时，可以直接从下拉框选择2025年
   - 无需手动输入

## 三、详细实现方案

### 3.1 用户管理页面角色化表单实现

#### 3.1.1 前端实现

**1. 修改角色选择为单选**

```vue
<!-- UserManagement.vue -->
<el-form-item label="角色" prop="roleCode" v-if="hasAnyRole(['ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN', 'ROLE_COLLEGE_LEADER', 'ROLE_CLASS_TEACHER'])">
  <el-select
    v-model="formData.roleCode"
    placeholder="请选择角色"
    style="width: 100%"
    @change="handleRoleChange"
  >
    <el-option
      v-for="role in filteredRoleList"
      :key="role.roleCode"
      :label="role.roleName"
      :value="role.roleCode"
    />
  </el-select>
  <div v-if="isEdit && rowRoles.length > 0" style="margin-top: 8px; font-size: 12px; color: #909399;">
    当前角色：{{ rowRoles.map(r => getRoleName(r)).join('、') }}
  </div>
</el-form-item>
```

**2. 根据角色动态显示表单字段**

```vue
<!-- 学生角色字段 -->
<template v-if="formData.roleCode === 'ROLE_STUDENT'">
  <el-form-item label="学号" prop="studentNo">
    <el-input v-model="formData.studentNo" placeholder="请输入学号" />
  </el-form-item>
  <el-form-item label="所属学校" prop="schoolId">
    <el-select
      v-model="formData.schoolId"
      placeholder="请选择学校"
      style="width: 100%"
      :disabled="isSchoolDisabledForAdd"
      @change="handleSchoolChangeForAdd"
    >
      <el-option
        v-for="school in schoolList"
        :key="school.schoolId"
        :label="school.schoolName"
        :value="school.schoolId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="所属学院" prop="collegeId">
    <el-select
      v-model="formData.collegeId"
      placeholder="请选择学院"
      style="width: 100%"
      :disabled="isCollegeDisabledForAdd || !formData.schoolId"
      @change="handleCollegeChangeForAdd"
    >
      <el-option
        v-for="college in collegeListForAdd"
        :key="college.collegeId"
        :label="college.collegeName"
        :value="college.collegeId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="所属专业" prop="majorId">
    <el-select
      v-model="formData.majorId"
      placeholder="请选择专业"
      style="width: 100%"
      :disabled="!formData.collegeId"
      @change="handleMajorChangeForAdd"
    >
      <el-option
        v-for="major in majorListForAdd"
        :key="major.majorId"
        :label="major.majorName"
        :value="major.majorId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="所属班级" prop="classId">
    <el-select
      v-model="formData.classId"
      placeholder="请选择班级"
      style="width: 100%"
      :disabled="!formData.majorId"
      :multiple="isClassMultipleForAdd"
    >
      <el-option
        v-for="classItem in classListForAdd"
        :key="classItem.classId"
        :label="classItem.className"
        :value="classItem.classId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="入学年份" prop="enrollmentYear">
    <el-select
      v-model="formData.enrollmentYear"
      placeholder="请选择入学年份"
      style="width: 100%"
    >
      <el-option
        v-for="year in enrollmentYearOptions"
        :key="year"
        :label="`${year}年`"
        :value="year"
      />
    </el-select>
  </el-form-item>
</template>

<!-- 学校管理员角色字段 -->
<template v-if="formData.roleCode === 'ROLE_SCHOOL_ADMIN'">
  <el-form-item label="所属学校" prop="schoolId">
    <el-select
      v-model="formData.schoolId"
      placeholder="请选择学校"
      style="width: 100%"
      :disabled="true"
    >
      <el-option
        v-for="school in schoolList"
        :key="school.schoolId"
        :label="school.schoolName"
        :value="school.schoolId"
      />
    </el-select>
  </el-form-item>
</template>

<!-- 学院负责人角色字段 -->
<template v-if="formData.roleCode === 'ROLE_COLLEGE_LEADER'">
  <el-form-item label="所属学校" prop="schoolId">
    <el-select
      v-model="formData.schoolId"
      placeholder="请选择学校"
      style="width: 100%"
      :disabled="true"
    >
      <el-option
        v-for="school in schoolList"
        :key="school.schoolId"
        :label="school.schoolName"
        :value="school.schoolId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="所属学院" prop="collegeId">
    <el-select
      v-model="formData.collegeId"
      placeholder="请选择学院"
      style="width: 100%"
      :disabled="true"
    >
      <el-option
        v-for="college in collegeListForAdd"
        :key="college.collegeId"
        :label="college.collegeName"
        :value="college.collegeId"
      />
    </el-select>
  </el-form-item>
</template>

<!-- 班主任角色字段 -->
<template v-if="formData.roleCode === 'ROLE_CLASS_TEACHER'">
  <el-form-item label="所属学校" prop="schoolId">
    <el-select
      v-model="formData.schoolId"
      placeholder="请选择学校"
      style="width: 100%"
      :disabled="true"
    >
      <el-option
        v-for="school in schoolList"
        :key="school.schoolId"
        :label="school.schoolName"
        :value="school.schoolId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="所属学院" prop="collegeId">
    <el-select
      v-model="formData.collegeId"
      placeholder="请选择学院"
      style="width: 100%"
      :disabled="true"
    >
      <el-option
        v-for="college in collegeListForAdd"
        :key="college.collegeId"
        :label="college.collegeName"
        :value="college.collegeId"
      />
    </el-select>
  </el-form-item>
  <el-form-item label="管理班级" prop="classIds">
    <el-select
      v-model="formData.classIds"
      placeholder="请选择管理的班级（可多选）"
      style="width: 100%"
      multiple
      collapse-tags
      collapse-tags-tooltip
    >
      <el-option
        v-for="classItem in classListForAdd"
        :key="classItem.classId"
        :label="classItem.className"
        :value="classItem.classId"
      />
    </el-select>
  </el-form-item>
</template>
```

**3. JavaScript逻辑实现**

```javascript
// 修改formData结构
const formData = reactive({
  userId: null,
  username: '',
  password: '',
  realName: '',
  idCard: '',
  phone: '',
  email: '',
  status: 1,
  roleCode: null,  // 改为单选，使用roleCode而不是roles数组
  // 学生相关字段
  studentNo: '',
  schoolId: null,
  collegeId: null,
  majorId: null,
  classId: null,
  enrollmentYear: null,
  // 班主任相关字段
  classIds: [],  // 班主任可以管理多个班级
  // 其他角色字段...
})

// 角色改变时的处理
const handleRoleChange = (roleCode) => {
  // 清空角色相关的字段
  formData.studentNo = ''
  formData.schoolId = null
  formData.collegeId = null
  formData.majorId = null
  formData.classId = null
  formData.classIds = []
  formData.enrollmentYear = null
  
  // 根据角色设置默认值
  if (roleCode === 'ROLE_SCHOOL_ADMIN') {
    // 学校管理员：默认绑定当前用户的学校
    if (currentOrgInfo.value.schoolId) {
      formData.schoolId = currentOrgInfo.value.schoolId
    }
  } else if (roleCode === 'ROLE_COLLEGE_LEADER') {
    // 学院负责人：默认绑定当前用户的学校、学院
    if (currentOrgInfo.value.schoolId) {
      formData.schoolId = currentOrgInfo.value.schoolId
      loadCollegeListForAdd(currentOrgInfo.value.schoolId)
    }
    if (currentOrgInfo.value.collegeId) {
      formData.collegeId = currentOrgInfo.value.collegeId
    }
  } else if (roleCode === 'ROLE_CLASS_TEACHER') {
    // 班主任：默认绑定当前用户的学校、学院
    if (currentOrgInfo.value.schoolId) {
      formData.schoolId = currentOrgInfo.value.schoolId
      loadCollegeListForAdd(currentOrgInfo.value.schoolId)
    }
    if (currentOrgInfo.value.collegeId) {
      formData.collegeId = currentOrgInfo.value.collegeId
      loadClassListForAdd(null, null, null, currentOrgInfo.value.collegeId)
    }
  }
}

// 计算属性：学校字段是否禁用（添加时）
const isSchoolDisabledForAdd = computed(() => {
  if (!formData.roleCode) return false
  const currentRoles = useAuthStore().roles || []
  
  // 学校管理员添加学校管理员：禁用
  if (formData.roleCode === 'ROLE_SCHOOL_ADMIN' && currentRoles.includes('ROLE_SCHOOL_ADMIN')) {
    return true
  }
  // 学院负责人添加学院负责人：禁用
  if (formData.roleCode === 'ROLE_COLLEGE_LEADER' && currentRoles.includes('ROLE_COLLEGE_LEADER')) {
    return true
  }
  // 班主任添加班主任：禁用
  if (formData.roleCode === 'ROLE_CLASS_TEACHER' && currentRoles.includes('ROLE_CLASS_TEACHER')) {
    return true
  }
  return false
})

// 计算属性：学院字段是否禁用（添加时）
const isCollegeDisabledForAdd = computed(() => {
  if (!formData.roleCode) return false
  const currentRoles = useAuthStore().roles || []
  
  // 学院负责人添加学院负责人：禁用
  if (formData.roleCode === 'ROLE_COLLEGE_LEADER' && currentRoles.includes('ROLE_COLLEGE_LEADER')) {
    return true
  }
  // 班主任添加班主任：禁用
  if (formData.roleCode === 'ROLE_CLASS_TEACHER' && currentRoles.includes('ROLE_CLASS_TEACHER')) {
    return true
  }
  return false
})

// 计算属性：班级是否支持多选（添加时）
const isClassMultipleForAdd = computed(() => {
  return formData.roleCode === 'ROLE_CLASS_TEACHER'
})

// 表单验证规则
const formRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, max: 20, message: '用户名长度为3-20个字符', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 20, message: '密码长度为6-20个字符', trigger: 'blur' }
  ],
  realName: [
    { required: true, message: '请输入真实姓名', trigger: 'blur' }
  ],
  roleCode: [
    { required: true, message: '请选择角色', trigger: 'change' }
  ],
  // 学生相关验证
  studentNo: [
    { required: true, message: '请输入学号', trigger: 'blur', validator: (rule, value, callback) => {
      if (formData.roleCode === 'ROLE_STUDENT' && !value) {
        callback(new Error('请输入学号'))
      } else {
        callback()
      }
    }}
  ],
  schoolId: [
    { required: true, message: '请选择学校', trigger: 'change', validator: (rule, value, callback) => {
      if (['ROLE_STUDENT', 'ROLE_SCHOOL_ADMIN', 'ROLE_COLLEGE_LEADER', 'ROLE_CLASS_TEACHER'].includes(formData.roleCode) && !value) {
        callback(new Error('请选择学校'))
      } else {
        callback()
      }
    }}
  ],
  collegeId: [
    { required: true, message: '请选择学院', trigger: 'change', validator: (rule, value, callback) => {
      if (['ROLE_STUDENT', 'ROLE_COLLEGE_LEADER', 'ROLE_CLASS_TEACHER'].includes(formData.roleCode) && !value) {
        callback(new Error('请选择学院'))
      } else {
        callback()
      }
    }}
  ],
  classId: [
    { required: true, message: '请选择班级', trigger: 'change', validator: (rule, value, callback) => {
      if (formData.roleCode === 'ROLE_STUDENT' && !value) {
        callback(new Error('请选择班级'))
      } else {
        callback()
      }
    }}
  ],
  enrollmentYear: [
    { required: true, message: '请选择入学年份', trigger: 'change', validator: (rule, value, callback) => {
      if (formData.roleCode === 'ROLE_STUDENT' && !value) {
        callback(new Error('请选择入学年份'))
      } else {
        callback()
      }
    }}
  ]
}

// 提交表单
const handleSubmit = async () => {
  if (!formRef.value) return
  
  await formRef.value.validate(async (valid) => {
    if (!valid) return
    
    submitting.value = true
    try {
      const userData = {
        username: formData.username,
        password: formData.password,
        realName: formData.realName,
        idCard: formData.idCard,
        phone: formData.phone,
        email: formData.email,
        status: formData.status,
        roles: [formData.roleCode]  // 转换为数组格式
      }
      
      // 根据角色添加额外字段
      if (formData.roleCode === 'ROLE_STUDENT') {
        userData.studentNo = formData.studentNo
        userData.schoolId = formData.schoolId
        userData.collegeId = formData.collegeId
        userData.majorId = formData.majorId
        userData.classId = formData.classId
        userData.enrollmentYear = formData.enrollmentYear
      } else if (formData.roleCode === 'ROLE_SCHOOL_ADMIN') {
        userData.schoolId = formData.schoolId
      } else if (formData.roleCode === 'ROLE_COLLEGE_LEADER') {
        userData.schoolId = formData.schoolId
        userData.collegeId = formData.collegeId
      } else if (formData.roleCode === 'ROLE_CLASS_TEACHER') {
        userData.schoolId = formData.schoolId
        userData.collegeId = formData.collegeId
        userData.classIds = formData.classIds
      }
      
      if (isEdit.value) {
        userData.userId = formData.userId
        const res = await userApi.updateUser(userData)
        if (res.code === 200) {
          ElMessage.success('更新成功')
          dialogVisible.value = false
          loadData()
        }
      } else {
        const res = await userApi.addUser(userData)
        if (res.code === 200) {
          ElMessage.success('添加成功')
          dialogVisible.value = false
          loadData()
        }
      }
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message || '操作失败'
      ElMessage.error(errorMessage)
    } finally {
      submitting.value = false
    }
  })
}
```

#### 3.1.2 后端实现

**1. 修改UserController，支持角色化字段**

```java
// UserController.java
@ApiOperation("添加用户")
@PostMapping
@PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN', 'ROLE_COLLEGE_LEADER', 'ROLE_CLASS_TEACHER')")
public Result<UserInfo> addUser(@RequestBody UserInfo user) {
    // 验证角色分配权限
    if (user.getRoles() != null && !user.getRoles().isEmpty()) {
        String roleCode = user.getRoles().get(0);  // 只取第一个角色
        if (!dataPermissionUtil.canAssignRole(roleCode)) {
            throw new BusinessException("无权限分配角色：" + roleCode);
        }
    }
    
    UserInfo result = userService.addUser(user);
    return Result.success("添加成功", result);
}
```

**2. 修改UserServiceImpl，根据角色创建对应实体**

```java
// UserServiceImpl.java
@Override
@Transactional(rollbackFor = Exception.class)
public UserInfo addUser(UserInfo user) {
    // ... 现有验证逻辑 ...
    
    // 保存用户
    this.save(user);
    
    // 根据角色创建对应的实体
    if (user.getRoles() != null && !user.getRoles().isEmpty()) {
        String roleCode = user.getRoles().get(0);
        
        if ("ROLE_STUDENT".equals(roleCode)) {
            // 创建学生信息
            Student student = new Student();
            student.setUserId(user.getUserId());
            student.setStudentNo(user.getStudentNo());  // 需要从UserInfo中获取
            student.setClassId(user.getClassId());
            student.setEnrollmentYear(user.getEnrollmentYear());
            student.setSchoolId(user.getSchoolId());
            student.setCollegeId(user.getCollegeId());
            student.setMajorId(user.getMajorId());
            studentService.addStudent(student);
        } else if ("ROLE_SCHOOL_ADMIN".equals(roleCode)) {
            // 创建学校管理员信息
            SchoolAdmin admin = new SchoolAdmin();
            admin.setUserId(user.getUserId());
            admin.setSchoolId(user.getSchoolId());
            schoolAdminService.addSchoolAdmin(admin);
        } else if ("ROLE_COLLEGE_LEADER".equals(roleCode)) {
            // 创建学院负责人信息（通过Teacher表）
            Teacher teacher = new Teacher();
            teacher.setUserId(user.getUserId());
            teacher.setCollegeId(user.getCollegeId());
            teacher.setSchoolId(user.getSchoolId());
            teacherService.addTeacherWithUser(teacher, "ROLE_COLLEGE_LEADER");
        } else if ("ROLE_CLASS_TEACHER".equals(roleCode)) {
            // 创建班主任信息（通过Teacher表）
            Teacher teacher = new Teacher();
            teacher.setUserId(user.getUserId());
            teacher.setCollegeId(user.getCollegeId());
            teacher.setSchoolId(user.getSchoolId());
            teacherService.addTeacherWithUser(teacher, "ROLE_CLASS_TEACHER");
            // 设置管理的班级
            if (user.getClassIds() != null && !user.getClassIds().isEmpty()) {
                // 关联班级逻辑...
            }
        }
    }
    
    return user;
}
```

### 3.2 教师管理页面职称下拉框实现

#### 3.2.1 前端实现

```vue
<!-- TeacherManagement.vue -->
<el-form-item label="职称" prop="title">
  <el-select
    v-model="formData.title"
    placeholder="请选择职称"
    style="width: 100%"
    filterable
    allow-create
    default-first-option
  >
    <el-option
      v-for="title in titleOptions"
      :key="title"
      :label="title"
      :value="title"
    />
  </el-select>
</el-form-item>
```

```javascript
// 职称选项
const titleOptions = [
  '教授',
  '副教授',
  '讲师',
  '助教',
  '研究员',
  '副研究员',
  '助理研究员',
  '高级工程师',
  '工程师',
  '助理工程师',
  '其他'
]
```

### 3.3 入学年份筛选优化实现（方案一：动态生成）

#### 3.3.1 后端实现

**1. 在StudentService中添加方法**

```java
// StudentService.java
/**
 * 获取所有不重复的入学年份（降序排列）
 * @return 入学年份列表
 */
List<Integer> getDistinctEnrollmentYears();
```

**2. 在StudentServiceImpl中实现**

```java
// StudentServiceImpl.java
@Override
public List<Integer> getDistinctEnrollmentYears() {
    LambdaQueryWrapper<Student> wrapper = new LambdaQueryWrapper<>();
    wrapper.select(Student::getEnrollmentYear)
           .eq(Student::getDeleteFlag, DeleteFlag.NORMAL.getCode())
           .isNotNull(Student::getEnrollmentYear)
           .groupBy(Student::getEnrollmentYear)
           .orderByDesc(Student::getEnrollmentYear);
    
    List<Student> students = this.list(wrapper);
    return students.stream()
                   .map(Student::getEnrollmentYear)
                   .distinct()
                   .sorted(Collections.reverseOrder())
                   .collect(Collectors.toList());
}
```

**3. 在StudentController中添加接口**

```java
// StudentController.java
@ApiOperation("获取所有入学年份")
@GetMapping("/enrollment-years")
@PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN', 'ROLE_COLLEGE_LEADER', 'ROLE_CLASS_TEACHER')")
public Result<List<Integer>> getEnrollmentYears() {
    List<Integer> years = studentService.getDistinctEnrollmentYears();
    return Result.success(years);
}
```

#### 3.3.2 前端实现

**1. 在student.js中添加API**

```javascript
// student.js
// 获取所有入学年份
getEnrollmentYears() {
  return request.get('/user/student/enrollment-years')
}
```

**2. 在UserManagement.vue中使用**

```javascript
// 入学年份选项（动态加载）
const enrollmentYearOptions = ref([])

// 加载入学年份
const loadEnrollmentYears = async () => {
  try {
    const res = await studentApi.getEnrollmentYears()
    if (res.code === 200) {
      enrollmentYearOptions.value = res.data || []
      // 如果没有数据，可以添加当前年份作为默认选项
      if (enrollmentYearOptions.value.length === 0) {
        const currentYear = new Date().getFullYear()
        enrollmentYearOptions.value = [currentYear, currentYear - 1, currentYear - 2]
      }
    }
  } catch (error) {
    console.error('加载入学年份失败:', error)
    // 失败时使用固定范围
    const currentYear = new Date().getFullYear()
    enrollmentYearOptions.value = []
    for (let i = currentYear; i >= currentYear - 10; i--) {
      enrollmentYearOptions.value.push(i)
    }
  }
}

// 在onMounted中调用
onMounted(async () => {
  // ... 其他初始化代码 ...
  await loadEnrollmentYears()
})
```

## 四、实施计划

### 4.1 开发阶段

| 阶段 | 任务 | 预计时间 | 优先级 |
|------|------|---------|--------|
| 阶段1 | 角色选择改为单选 | 1小时 | P0 |
| 阶段2 | 实现角色化表单字段显示 | 4小时 | P0 |
| 阶段3 | 实现角色默认值绑定逻辑 | 2小时 | P0 |
| 阶段4 | 后端支持角色化字段处理 | 3小时 | P0 |
| 阶段5 | 教师管理职称下拉框 | 1小时 | P1 |
| 阶段6 | 入学年份动态加载 | 2小时 | P1 |
| 阶段7 | 测试与优化 | 2小时 | P1 |

**总计**：约15小时

### 4.2 测试要点

1. **角色化表单测试**：
   - 测试不同角色添加用户时，表单字段是否正确显示
   - 测试默认值绑定是否正确
   - 测试字段禁用逻辑是否正确
   - 测试表单验证是否生效

2. **角色选择测试**：
   - 测试角色选择是否为单选
   - 测试角色切换时，表单字段是否正确更新

3. **职称下拉框测试**：
   - 测试下拉框选项是否正确
   - 测试是否支持自定义输入

4. **入学年份测试**：
   - 测试动态加载是否正确
   - 测试无数据时的处理
   - 测试筛选功能是否正常

## 五、注意事项

1. **数据一致性**：
   - 确保用户、学生、教师等实体的数据一致性
   - 添加用户时，需要同时创建对应的角色实体

2. **权限控制**：
   - 严格验证角色分配权限
   - 确保用户只能添加有权限的角色

3. **用户体验**：
   - 表单字段的显示/隐藏要流畅
   - 默认值设置要合理
   - 错误提示要清晰

4. **向后兼容**：
   - 编辑用户时，需要兼容旧数据格式
   - 如果用户有多个角色，需要处理兼容逻辑

## 六、后续优化建议

1. **表单字段缓存**：
   - 可以考虑缓存学校、学院、专业、班级列表
   - 减少重复请求

2. **批量添加**：
   - 可以考虑支持批量添加学生
   - 使用Excel导入功能

3. **角色权限可视化**：
   - 可以在表单中显示当前用户可以添加的角色范围
   - 提供权限说明

---

**文档版本**：v1.0  
**创建时间**：2025-11-25  
**最后更新**：2025-11-25

