# 动态菜单实现示例

本文档提供了三种动态菜单方案的完整实现示例。

## 方案一：基于配置文件的动态菜单（推荐）

### 1. 配置文件 (`menu.config.js`)
已创建，见 `internship-web/src/config/menu.config.js`

### 2. 使用示例 (`MainLayout.vue`)
已创建示例文件，见 `internship-web/src/components/common/MainLayout.vue.example`

### 3. 关键代码

```vue
<script setup>
import { computed } from 'vue'
import { useAuthStore } from '@/store/modules/auth'
import { filterMenuByRoles } from '@/config/menu.config'

const authStore = useAuthStore()

// 根据用户角色过滤菜单
const filteredMenus = computed(() => {
  const roles = authStore.roles || []
  return filterMenuByRoles(roles)
})
</script>

<template>
  <el-menu>
    <template v-for="menuItem in filteredMenus" :key="menuItem.index">
      <el-sub-menu v-if="menuItem.children" :index="menuItem.index">
        <!-- 子菜单 -->
      </el-sub-menu>
      <el-menu-item v-else :index="menuItem.index">
        <!-- 菜单项 -->
      </el-menu-item>
    </template>
  </el-menu>
</template>
```

---

## 方案二：基于后端API的动态菜单

### 1. 后端API接口

```java
@RestController
@RequestMapping("/api/menu")
public class MenuController {
    
    @Autowired
    private MenuService menuService;
    
    @GetMapping
    public Result<List<MenuVO>> getMenus() {
        // 获取当前用户角色
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        List<String> roles = userDetails.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .filter(authority -> authority.startsWith("ROLE_"))
            .collect(Collectors.toList());
        
        // 根据角色获取菜单
        List<MenuVO> menus = menuService.getMenusByRoles(roles);
        return Result.success(menus);
    }
}
```

### 2. 前端API调用

```javascript
// api/menu.js
import request from '@/utils/request'

export const menuApi = {
  getMenus() {
    return request.get('/menu')
  }
}
```

### 3. Store中缓存菜单

```javascript
// store/modules/menu.js
import { defineStore } from 'pinia'
import { menuApi } from '@/api/menu'

export const useMenuStore = defineStore('menu', {
  state: () => ({
    menus: [],
    loaded: false
  }),
  
  actions: {
    async loadMenus() {
      if (this.loaded) {
        return this.menus
      }
      
      try {
        const res = await menuApi.getMenus()
        if (res.code === 200) {
          this.menus = res.data
          this.loaded = true
        }
        return this.menus
      } catch (error) {
        console.error('加载菜单失败:', error)
        return []
      }
    },
    
    clearMenus() {
      this.menus = []
      this.loaded = false
    }
  }
})
```

### 4. 在MainLayout中使用

```vue
<script setup>
import { ref, computed, onMounted } from 'vue'
import { useMenuStore } from '@/store/modules/menu'
import { useAuthStore } from '@/store/modules/auth'

const menuStore = useMenuStore()
const authStore = useAuthStore()

const menus = computed(() => menuStore.menus)

onMounted(async () => {
  // 登录后加载菜单
  if (authStore.isAuthenticated) {
    await menuStore.loadMenus()
  }
})

// 监听登录状态变化
watch(() => authStore.isAuthenticated, async (isAuth) => {
  if (isAuth) {
    await menuStore.loadMenus()
  } else {
    menuStore.clearMenus()
  }
})
</script>
```

---

## 方案三：基于角色的菜单配置对象

### 1. 角色菜单配置

```javascript
// config/role-menu.config.js
export const roleMenus = {
  // 系统管理员菜单
  ROLE_SYSTEM_ADMIN: [
    { index: '/dashboard', title: '首页', icon: 'House' },
    {
      index: 'system',
      title: '系统管理',
      icon: 'Setting',
      children: [
        { index: '/admin/system/school', title: '学校管理', icon: 'School' },
        { index: '/admin/system/college', title: '学院管理', icon: 'OfficeBuilding' },
        // ... 更多菜单项
      ]
    },
    // ... 更多菜单
  ],
  
  // 学校管理员菜单
  ROLE_SCHOOL_ADMIN: [
    { index: '/dashboard', title: '首页', icon: 'House' },
    {
      index: 'system',
      title: '系统管理',
      icon: 'Setting',
      children: [
        { index: '/admin/system/college', title: '学院管理', icon: 'OfficeBuilding' },
        // ... 更多菜单项
      ]
    },
    // ... 更多菜单
  ],
  
  // 学生菜单
  ROLE_STUDENT: [
    { index: '/dashboard', title: '首页', icon: 'House' },
    {
      index: 'internship-student',
      title: '实习管理',
      icon: 'Document',
      children: [
        { index: '/student/internship/post', title: '岗位列表', icon: 'List' },
        { index: '/student/internship/apply', title: '实习申请', icon: 'EditPen' },
        // ... 更多菜单项
      ]
    }
  ]
  
  // ... 其他角色菜单
}
```

### 2. 菜单合并函数（支持多角色）

```javascript
// utils/menu-helper.js
import { roleMenus } from '@/config/role-menu.config'

/**
 * 根据用户角色获取菜单
 * @param {string[]} roles 用户角色列表
 * @returns {Array} 合并后的菜单
 */
export function getMenusByRoles(roles) {
  if (!roles || roles.length === 0) {
    return []
  }
  
  // 收集所有角色的菜单
  const allMenus = []
  roles.forEach(role => {
    if (roleMenus[role]) {
      allMenus.push(...roleMenus[role])
    }
  })
  
  // 合并相同index的菜单项（合并子菜单）
  const menuMap = new Map()
  
  allMenus.forEach(menu => {
    if (menuMap.has(menu.index)) {
      // 如果已存在，合并子菜单
      const existingMenu = menuMap.get(menu.index)
      if (menu.children && existingMenu.children) {
        // 合并子菜单，去重
        const childrenMap = new Map()
        existingMenu.children.forEach(child => {
          childrenMap.set(child.index, child)
        })
        menu.children.forEach(child => {
          childrenMap.set(child.index, child)
        })
        existingMenu.children = Array.from(childrenMap.values())
      } else if (menu.children) {
        existingMenu.children = menu.children
      }
    } else {
      menuMap.set(menu.index, { ...menu })
    }
  })
  
  return Array.from(menuMap.values())
}
```

### 3. 在MainLayout中使用

```vue
<script setup>
import { computed } from 'vue'
import { useAuthStore } from '@/store/modules/auth'
import { getMenusByRoles } from '@/utils/menu-helper'

const authStore = useAuthStore()

const menus = computed(() => {
  const roles = authStore.roles || []
  return getMenusByRoles(roles)
})
</script>
```

---

## 方案对比

| 特性 | 方案一（配置文件） | 方案二（后端API） | 方案三（角色配置） |
|------|------------------|-----------------|------------------|
| 实现复杂度 | ⭐⭐ 中等 | ⭐⭐⭐ 较高 | ⭐ 简单 |
| 性能 | ⭐⭐⭐ 优秀 | ⭐⭐ 良好 | ⭐⭐⭐ 优秀 |
| 安全性 | ⭐⭐ 中等 | ⭐⭐⭐ 优秀 | ⭐⭐ 中等 |
| 灵活性 | ⭐⭐⭐ 优秀 | ⭐⭐⭐ 优秀 | ⭐⭐ 中等 |
| 维护性 | ⭐⭐⭐ 优秀 | ⭐⭐ 良好 | ⭐ 一般 |
| 适用场景 | 菜单相对稳定 | 菜单经常变化 | 角色数量少 |

## 推荐

**推荐使用方案一**，因为：
1. 配置集中，易于维护
2. 性能好，无需API调用
3. 支持动态标题等高级特性
4. 代码结构清晰，易于扩展

