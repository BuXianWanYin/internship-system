# 高校实习过程跟踪与评价管理系统 - 前后端开发规范文档

## 一、项目概述

### 1.1 技术栈
- **后端技术栈**：Spring Boot 2.7.6 + MyBatis Plus + JWT + Redis + Spring Security
- **前端技术栈**：Vue 3 + Vite + Element Plus
- **数据库**：MySQL 8
- **开发工具**：JDK 1.8、Maven 3.6+
- **接口文档**：Swagger

### 1.2 项目结构要求
- 后端采用分层架构，严格遵循MVC模式
- 前端采用组件化开发，模块化管理
- 前后端分离，通过RESTful API进行交互
- 使用Swagger实现接口文档自动生成

## 二、后端开发规范

### 2.1 项目包结构规范

#### 2.1.1 基础包结构
```
com.server.internshipserver
├── common                    # 公共模块
│   ├── config               # 配置类
│   │   ├── SecurityConfig   # Spring Security配置
│   │   ├── RedisConfig      # Redis配置
│   │   ├── MybatisPlusConfig # MyBatis Plus配置
│   │   ├── SwaggerConfig    # Swagger配置
│   │   └── CorsConfig       # 跨域配置
│   ├── constant             # 常量定义
│   ├── enums                # 枚举类
│   ├── exception            # 异常处理
│   │   ├── GlobalExceptionHandler # 全局异常处理器
│   │   └── BusinessException # 业务异常类
│   ├── utils                # 工具类
│   │   ├── JwtUtil          # JWT工具类
│   │   ├── RedisUtil        # Redis工具类
│   │   └── SecurityUtil     # 安全工具类
│   ├── result               # 统一响应结果
│   │   ├── Result           # 响应结果封装
│   │   └── ResultCode       # 响应码定义
│   └── dto                  # 跨模块通用DTO（可选）
│       └── FileUploadResult # 文件上传结果DTO（示例）
├── domain                    # 实体类（Domain层）
│   ├── system               # 系统管理模块实体
│   │   ├── School           # 学校实体
│   │   ├── College          # 学院实体
│   │   ├── Major            # 专业实体
│   │   ├── Class            # 班级实体
│   │   └── SystemConfig     # 系统配置实体
│   ├── user                 # 用户模块实体
│   │   ├── User             # 用户基础实体
│   │   ├── Student          # 学生实体
│   │   ├── Teacher          # 教师实体
│   │   ├── Enterprise       # 企业实体
│   │   ├── EnterpriseMentor # 企业导师实体
│   │   └── dto              # 用户模块DTO
│   │       ├── StudentImportDTO    # 学生导入DTO
│   │       └── StudentImportResult # 学生导入结果DTO
│   ├── internship           # 实习模块实体
│   │   ├── InternshipPlan   # 实习计划实体
│   │   ├── InternshipPost   # 实习岗位实体
│   │   ├── InternshipApply  # 实习申请实体
│   │   ├── InternshipLog    # 实习日志实体
│   │   ├── InternshipWeeklyReport # 周报实体
│   │   ├── Attendance       # 考勤记录实体
│   │   └── InternshipFeedback # 问题反馈实体
│   ├── evaluation           # 评价模块实体
│   │   ├── EvaluationIndex  # 评价指标实体
│   │   ├── EnterpriseEvaluation # 企业评价实体
│   │   ├── SchoolEvaluation # 学校评价实体
│   │   ├── SelfEvaluation   # 学生自评实体
│   │   └── ComprehensiveScore # 综合成绩实体
│   └── cooperation          # 校企协同模块实体
│       ├── InformationShare # 信息共享实体
│       ├── Message          # 站内信实体
│       └── Notice           # 通知公告实体
├── mapper                    # 数据访问层（Mapper层）
│   ├── system               # 系统管理Mapper
│   ├── user                 # 用户管理Mapper
│   ├── internship           # 实习管理Mapper
│   ├── evaluation           # 评价管理Mapper
│   └── cooperation          # 校企协同Mapper
├── service                   # 业务逻辑层接口（Service层）
│   ├── system               # 系统管理Service接口
│   ├── user                 # 用户管理Service接口
│   ├── internship           # 实习管理Service接口
│   ├── evaluation           # 评价管理Service接口
│   └── cooperation          # 校企协同Service接口
├── service.impl             # 业务逻辑层实现（ServiceImpl层）
│   ├── system               # 系统管理Service实现
│   ├── user                 # 用户管理Service实现
│   ├── internship           # 实习管理Service实现
│   ├── evaluation           # 评价管理Service实现
│   └── cooperation          # 校企协同Service实现
├── controller               # 控制器层（Controller层）
│   ├── system               # 系统管理Controller
│   │   ├── SchoolController      # 学校管理控制器
│   │   ├── CollegeController     # 学院管理控制器
│   │   ├── MajorController       # 专业管理控制器
│   │   ├── ClassController       # 班级管理控制器
│   │   └── SystemConfigController # 系统配置控制器
│   ├── user                 # 用户管理Controller
│   │   ├── UserController        # 用户基础控制器
│   │   ├── StudentController      # 学生管理控制器
│   │   ├── TeacherController      # 教师管理控制器
│   │   ├── EnterpriseController   # 企业管理控制器
│   │   └── AuthController         # 认证授权控制器
│   ├── internship           # 实习管理Controller
│   │   ├── InternshipPlanController   # 实习计划控制器
│   │   ├── InternshipPostController   # 实习岗位控制器
│   │   ├── InternshipApplyController  # 实习申请控制器
│   │   ├── InternshipLogController    # 实习日志控制器
│   │   ├── AttendanceController       # 考勤管理控制器
│   │   └── InternshipFeedbackController # 反馈管理控制器
│   ├── evaluation           # 评价管理Controller
│   │   ├── EvaluationIndexController  # 评价指标控制器
│   │   ├── EnterpriseEvaluationController # 企业评价控制器
│   │   ├── SchoolEvaluationController # 学校评价控制器
│   │   └── ComprehensiveScoreController # 综合成绩控制器
│   └── cooperation          # 校企协同Controller
│       ├── InformationShareController # 信息共享控制器
│       ├── MessageController         # 站内信控制器
│       └── NoticeController          # 通知公告控制器
└── security                 # 安全模块
    ├── filter               # 过滤器
    │   ├── JwtAuthenticationFilter # JWT认证过滤器
    │   └── JwtAuthorizationFilter  # JWT授权过滤器
    ├── handler              # 处理器
    │   ├── AuthenticationSuccessHandler # 认证成功处理器
    │   ├── AuthenticationFailureHandler # 认证失败处理器
    │   └── AccessDeniedHandler      # 访问拒绝处理器
    └── service              # 安全服务
        └── UserDetailsServiceImpl  # 用户详情服务实现
```

#### 2.1.2 包结构设计原则
- **单一职责原则**：每个包只负责一个业务模块
- **分层清晰**：Domain、Mapper、Service、Controller严格分离
- **模块独立**：不同业务模块之间通过接口交互，降低耦合
- **权限隔离**：不同角色的控制器分开，便于权限控制

### 2.2 Domain层（实体类）规范

#### 2.2.1 实体类命名规范
- 实体类使用大驼峰命名，如：`School`、`Student`、`InternshipPlan`
- 实体类必须实现`Serializable`接口
- 实体类必须添加`@Data`注解（Lombok）
- 实体类必须添加`@TableName`注解指定表名

#### 2.2.2 实体类字段规范
- 主键字段必须使用`@TableId`注解，类型为`IdType.AUTO`
- 字段必须使用`@TableField`注解指定数据库字段名
- 时间字段使用`LocalDateTime`类型，并添加`@JsonFormat`注解格式化
- 自动填充字段使用`@TableField(fill = FieldFill.INSERT_UPDATE)`注解
- 所有字段必须添加`@ApiModelProperty`注解用于API文档说明
- 字段命名使用小驼峰，数据库字段使用下划线命名
- **敏感字段保护**：密码等敏感字段必须使用`@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`注解
  - 该注解允许反序列化时接收字段值（如登录时接收密码）
  - 但禁止序列化时返回字段值（防止响应中泄露密码）
  - **禁止使用`@JsonIgnore`**：该注解会同时禁止序列化和反序列化，导致无法接收登录密码等场景

#### 2.2.3 实体类示例规范
```java
// 实体类必须包含以下要素：
1. 实现Serializable接口
2. 定义serialVersionUID常量
3. 主键字段使用@TableId注解
4. 时间字段使用@TableField和@JsonFormat注解
5. 所有字段添加@ApiModelProperty注解
6. 使用@Data注解简化getter/setter
7. 敏感字段使用@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)注解
```

#### 2.2.4 敏感字段保护示例
```java
// 正确示例：使用@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
@ApiModelProperty(value = "密码（BCrypt加密）", required = true, hidden = true)
@TableField("password")
@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)  // 允许接收，禁止返回
private String password;

// 错误示例1：使用@JsonIgnore（会同时禁止接收和返回）
@JsonIgnore  // ❌ 错误：会导致登录时无法接收密码
private String password;

// 错误示例2：不使用任何注解（会同时允许接收和返回）
private String password;  // ❌ 错误：响应中会泄露密码
```

#### 2.2.5 导入规范
- **必须使用import导入**：所有类必须通过import语句导入，禁止在代码中使用完整类名（如`com.baomidou.mybatisplus.annotation.FieldFill.INSERT_UPDATE`）
- **正确示例**：
  ```java
  import com.baomidou.mybatisplus.annotation.FieldFill;
  
  @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
  ```
- **错误示例**：
  ```java
  // 禁止使用完整类名
  @TableField(value = "update_time", fill = com.baomidou.mybatisplus.annotation.FieldFill.INSERT_UPDATE)
  ```
- **特殊情况**：当类名冲突时（如`domain.user.User`与`org.springframework.security.core.userdetails.User`），允许使用完整类名，但必须添加注释说明原因
  ```java
  // 注意：由于与domain.user.User类名冲突，此处使用完整类名
  return org.springframework.security.core.userdetails.User.builder()
          .username(user.getUsername())
          .build();
  ```

#### 2.2.6 实体类字段类型规范
- **主键类型**：统一使用`String`类型（如示例代码）或`Long`类型
- **时间类型**：统一使用`LocalDateTime`
- **布尔类型**：使用`Boolean`包装类型
- **数值类型**：根据业务需求选择`Integer`、`Long`、`BigDecimal`
- **字符串类型**：使用`String`，根据长度限制添加`@TableField`注解

### 2.2.7 DTO类规范

#### 2.2.7.1 DTO类位置规范
- **DTO类必须放在对应模块的`domain`包下的`dto`子包中**，如：`domain.user.dto`、`domain.system.dto`
- **禁止**：将DTO类放在`controller`包或`controller`的子包下（如：`controller.user.dto`）
- **禁止**：将DTO类放在`common.dto`包下（除非是跨模块的通用DTO）
- DTO类用于特殊情况下的数据传输，如：文件导入、复杂查询参数、特殊验证场景等
- DTO类命名格式：`功能描述 + DTO`，如：`StudentImportDTO`、`StudentImportResult`

#### 2.2.7.2 DTO类使用场景
- **文件导入/导出**：Excel导入导出、文件上传等场景
- **复杂查询参数**：多条件组合查询、统计查询等
- **特殊验证场景**：需要特殊字段组合或验证的场景
- **跨模块数据传输**：不同模块间需要传递的数据（此类DTO可放在`common.dto`包下）

#### 2.2.7.3 DTO类规范要求
- DTO类必须添加`@ApiModel`注解用于Swagger文档
- 所有字段必须添加`@ApiModelProperty`注解说明
- 使用Lombok的`@Data`注解简化getter/setter
- DTO类命名必须具有业务含义，清晰表达用途

#### 2.2.7.4 DTO类位置示例
- **正确示例1**：学生相关DTO放在`domain.user.dto`包下
  ```java
  package com.server.internshipserver.domain.user.dto;
  public class StudentImportDTO { ... }
  ```
- **正确示例2**：系统相关DTO放在`domain.system.dto`包下
  ```java
  package com.server.internshipserver.domain.system.dto;
  public class SystemConfigDTO { ... }
  ```
- **正确示例3**：跨模块通用DTO放在`common.dto`包下
  ```java
  package com.server.internshipserver.common.dto;
  public class FileUploadResult { ... }
  ```
- **错误示例**：DTO放在controller包下
  ```java
  package com.server.internshipserver.controller.user.dto;  // ❌ 错误
  public class StudentImportDTO { ... }
  ```

#### 2.2.7.5 DTO类组织原则
- **领域驱动**：DTO应该和对应的实体类放在同一个领域模块下，便于管理和维护
- **模块隔离**：不同模块的DTO应该分开，避免混在一起
- **职责清晰**：DTO只用于数据传输，不包含业务逻辑

### 2.3 Mapper层规范

#### 2.3.1 Mapper接口规范
- Mapper接口必须继承`BaseMapper<T>`，T为对应的实体类
- Mapper接口命名格式：`实体类名 + Mapper`，如：`SchoolMapper`
- Mapper接口必须添加`@Mapper`注解或在启动类添加`@MapperScan`
- 自定义查询方法必须使用`@Select`、`@Update`、`@Insert`、`@Delete`注解
- 复杂查询建议使用XML映射文件

#### 2.3.2 Mapper方法命名规范
- 查询方法：`select + 实体名 + By + 条件`，如：`selectSchoolBySchoolId`
- 更新方法：`update + 实体名 + By + 条件`
- 删除方法：`delete + 实体名 + By + 条件`
- 插入方法：`insert + 实体名`

#### 2.3.3 Mapper示例规范
```java
// Mapper接口必须：
1. 继承BaseMapper<实体类>
2. 添加@Mapper注解
3. 自定义方法添加相应注解
4. 方法命名遵循规范
```

### 2.4 Service层规范

#### 2.4.1 Service接口规范
- Service接口必须继承`IService<T>`，T为对应的实体类
- Service接口命名格式：`实体类名 + Service`，如：`SchoolService`
- Service接口方法必须添加JavaDoc注释，说明方法功能、参数、返回值
- Service接口方法命名使用动词开头，如：`select`、`add`、`update`、`delete`

#### 2.4.2 Service实现类规范
- Service实现类必须继承`ServiceImpl<Mapper, Entity>`并实现对应的Service接口
- Service实现类必须添加`@Service`注解
- Service实现类必须注入对应的Mapper
- Service实现类方法必须添加`@Override`注解
- 业务逻辑复杂的方法必须添加详细注释

#### 2.4.3 Service层职责划分
- **单一职责**：一个Service实现类只负责一个实体类的业务逻辑
- **不可跨模块**：用户Service不能处理实习业务，实习Service不能处理评价业务
- **权限校验**：Service层方法内部必须进行权限校验和数据权限过滤
- **事务管理**：涉及数据修改的方法必须添加`@Transactional`注解

#### 2.4.4 Service方法规范
- 查询方法：返回实体对象或实体列表
- 新增方法：返回操作结果或新增的实体对象
- 更新方法：返回操作结果或更新的实体对象
- 删除方法：返回操作结果（软删除）
- 所有方法必须进行参数校验和异常处理

#### 2.4.5 Service代码质量规范

##### 2.4.5.1 控制流嵌套规范
- **嵌套层级限制**：方法中的 if/else 嵌套层级不应超过 3 层
- **提取方法**：当嵌套层级超过 3 层时，必须提取为私有方法
- **提前返回**：优先使用提前返回（Early Return）模式，减少嵌套
- **卫语句**：使用卫语句（Guard Clauses）处理异常情况

**示例：避免深层嵌套**
```java
// ❌ 错误示例：嵌套层级过深（4-5层）
public Page<Class> getClassPage(...) {
    if (schoolId != null) {
        List<College> colleges = ...;
        if (colleges != null && !colleges.isEmpty()) {
            List<Long> collegeIds = ...;
            List<Major> majors = ...;
            if (majors != null && !majors.isEmpty()) {
                List<Long> majorIds = ...;
                wrapper.in(Class::getMajorId, majorIds);
            } else {
                wrapper.eq(Class::getClassId, -1L);
            }
        } else {
            wrapper.eq(Class::getClassId, -1L);
        }
    }
    // ... 更多嵌套
}

// ✅ 正确示例：提取方法，减少嵌套
public Page<Class> getClassPage(...) {
    LambdaQueryWrapper<Class> wrapper = new LambdaQueryWrapper<>();
    applyOrgFilter(wrapper, schoolId, collegeId, majorId);
    applyDataPermissionFilter(wrapper);
    return this.page(page, wrapper);
}

private void applyOrgFilter(LambdaQueryWrapper<Class> wrapper, ...) {
    if (majorId != null) {
        wrapper.eq(Class::getMajorId, majorId);
        return; // 提前返回
    }
    // ... 其他逻辑
}
```

##### 2.4.5.2 方法长度规范
- **方法长度限制**：单个方法代码行数不应超过 80 行
- **职责单一**：方法应只做一件事，保持职责单一
- **提取方法**：当方法过长时，应提取为多个私有方法

##### 2.4.5.3 代码可读性规范
- **方法命名**：方法名应清晰表达方法功能
- **注释规范**：复杂业务逻辑必须添加注释说明
- **变量命名**：变量名应具有业务含义，避免使用单字母变量

### 2.5 Controller层规范

#### 2.5.1 Controller类规范
- Controller类必须添加`@RestController`注解
- Controller类必须添加`@RequestMapping`注解指定基础路径
- Controller类必须添加`@Api`注解（Swagger）用于API文档分组
- Controller类命名格式：`功能模块 + Controller`，如：`SchoolController`
- Controller必须注入对应的Service接口

#### 2.5.2 Controller方法规范
- 所有方法必须添加`@ApiOperation`注解（Swagger）说明接口功能
- 所有方法必须添加`@PreAuthorize`注解进行权限控制
- 请求参数必须使用`@RequestBody`或`@RequestParam`注解，并添加`@ApiParam`注解（Swagger）说明参数
- 返回结果必须使用统一的`Result`封装
- 方法命名使用RESTful风格：`get`、`post`、`put`、`delete`
- **使用Domain实体**：Controller层直接使用Domain实体类作为请求和响应对象，不创建额外的DTO类（特殊情况除外，如需要特殊验证或字段组合）
- **DTO使用规范**：如需使用DTO，必须从`domain`包下的`dto`子包导入，禁止在`controller`包下创建DTO类

#### 2.5.2.1 Controller层职责（重要）
- **禁止在Controller中编写业务逻辑**：所有业务逻辑必须放在Service层
- **Controller只负责**：
  1. 接收HTTP请求参数
  2. 调用Service层方法
  3. 将Service层返回结果封装为`Result`对象返回
  4. 异常处理（通过全局异常处理器统一处理）
- **禁止在Controller中**：
  - ❌ 进行业务判断（如：if判断、数据验证、业务计算等）
  - ❌ 调用多个Service方法组合业务逻辑
  - ❌ 直接操作数据库（调用Mapper）
  - ❌ 构建复杂的数据结构（如：Map、List等业务数据组装）
  - ❌ 文件解析、数据转换等业务操作
  - ❌ 获取当前用户信息用于业务判断（应在Service层处理）
- **正确示例**：
  ```java
  @PostMapping("/login")
  public Result<Map<String, Object>> login(@RequestBody UserInfo loginUser) {
      Map<String, Object> data = authService.login(loginUser);
      return Result.success("登录成功", data);
  }
  ```
- **错误示例**：
  ```java
  @PostMapping("/login")
  public Result<Map<String, Object>> login(@RequestBody UserInfo loginUser) {
      // ❌ 错误：在Controller中进行参数校验
      if (loginUser.getUsername() == null) {
          return Result.error("用户名不能为空");
      }
      // ❌ 错误：在Controller中调用多个Service
      UserInfo user = userService.getUserByUsername(loginUser.getUsername());
      String token = jwtUtil.generateToken(user);
      // ❌ 错误：在Controller中构建业务数据
      Map<String, Object> data = new HashMap<>();
      data.put("token", token);
      return Result.success("登录成功", data);
  }
  ```

#### 2.5.3 Controller职责划分原则
- **严格分离**：不同业务模块必须使用不同的Controller
- **角色分离**：不同角色的操作必须使用不同的Controller
  - 学生操作：`StudentController`
  - 教师操作：`TeacherController`
  - 管理员操作：`AdminController`或按模块划分
  - 企业操作：`EnterpriseController`
- **不可混用**：一个Controller不能同时处理多个角色的业务逻辑
- **权限隔离**：每个Controller方法必须明确权限要求

#### 2.5.4 RESTful API设计规范
- **GET**：查询操作，如：`GET /api/school/{id}`
- **POST**：新增操作，如：`POST /api/school`
- **PUT**：更新操作，如：`PUT /api/school/{id}`
- **DELETE**：删除操作，如：`DELETE /api/school/{id}`
- **路径命名**：使用小写字母和下划线，如：`/api/internship_plan`

#### 2.5.5 Controller方法示例规范
```java
// Controller方法标准模板：
@ApiOperation("接口功能说明")
@PreAuthorize("权限表达式")
@PostMapping("/path")
public Result<返回类型> methodName(@RequestBody 参数类型 param) {
    // 1. 直接调用Service层方法（所有业务逻辑在Service层）
    返回类型 result = service.methodName(param);
    // 2. 封装返回结果
    return Result.success("操作成功", result);
}

// 注意：
// - 参数校验应在Service层进行，Controller层不进行业务校验
// - 异常处理由全局异常处理器统一处理，Controller层不需要try-catch
// - 数据组装、业务判断等所有逻辑都在Service层完成
```

#### 2.5.6 Swagger配置规范
- 项目必须集成Swagger 2.x或Swagger 3.x（Springfox或Springdoc）
- 创建Swagger配置类，配置API文档基本信息
- 配置API文档访问路径（如：`/swagger-ui.html`或`/swagger-ui/index.html`）
- 配置API文档分组，按模块划分
- 生产环境建议关闭Swagger文档访问
- 所有Controller类必须添加`@Api`注解，指定分组和描述
- 所有Controller方法必须添加`@ApiOperation`注解，说明接口功能
- 所有请求参数必须添加`@ApiParam`或`@ApiModelProperty`注解，说明参数含义
- 实体类必须添加`@ApiModel`注解，说明实体类用途

### 2.6 权限控制规范

#### 2.6.1 角色定义
系统定义八种角色：
1. **ROLE_SYSTEM_ADMIN**：系统管理员（最高权限）
2. **ROLE_SCHOOL_ADMIN**：学校管理员（单所学校权限）
3. **ROLE_COLLEGE_LEADER**：学院负责人（单个学院权限）
4. **ROLE_CLASS_TEACHER**：班主任（单个班级权限）
5. **ROLE_INSTRUCTOR**：指导教师（分配学生权限）
6. **ROLE_ENTERPRISE_ADMIN**：企业管理员（本企业权限）
7. **ROLE_ENTERPRISE_MENTOR**：企业导师（本企业实习生权限）
8. **ROLE_STUDENT**：学生（个人数据权限）

#### 2.6.2 权限控制实现方式
- **方法级权限**：使用`@PreAuthorize`注解，如：`@PreAuthorize("hasRole('ROLE_SCHOOL_ADMIN')")`
- **数据级权限**：在Service层实现数据过滤，确保用户只能访问权限范围内的数据
- **URL级权限**：在Spring Security配置中定义URL访问规则
- **前端权限**：前端根据用户角色动态显示菜单和按钮

#### 2.6.3 权限控制规则
- **系统管理员**：可以访问所有接口和数据
- **学校管理员**：只能访问本校数据，自动过滤其他学校数据
- **学院负责人**：只能访问本院数据，自动过滤其他学院数据
- **班主任**：只能访问本班数据，自动过滤其他班级数据
- **指导教师**：只能访问分配的学生数据
- **企业管理员**：只能访问本企业数据
- **企业导师**：只能访问本企业实习生数据
- **学生**：只能访问个人数据

#### 2.6.3.1 角色分配权限矩阵
各角色在添加用户/教师/学生时，可以分配的角色权限如下表：

| 当前角色 | 系统管理员 | 学校管理员 | 学院负责人 | 班主任 | 指导教师 | 学生 | 企业管理员 | 企业导师 |
|---------|-----------|-----------|-----------|--------|---------|------|-----------|---------|
| **系统管理员** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| **学校管理员** | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| **学院负责人** | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| **班主任** | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ❌ | ❌ |
| **企业管理员** | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |

**权限说明：**
- ✅ 表示可以分配该角色
- ❌ 表示不能分配该角色
- **系统管理员**：可以分配所有角色（最高权限）
- **学校管理员**：可以分配学校相关角色（学校管理员、学院负责人、班主任、指导教师、学生），不能分配企业相关角色
- **学院负责人**：只能分配教师相关角色（学院负责人、班主任、指导教师）和学生角色，不能分配系统管理员、学校管理员、企业相关角色
- **班主任**：只能分配学生角色，不能分配其他任何角色
- **企业管理员**：只能分配企业导师角色，不能分配其他任何角色

#### 2.6.3.2 用户编辑权限矩阵
各角色在编辑用户信息时的权限如下表：

| 当前角色 | 系统管理员 | 学校管理员 | 学院负责人 | 班主任 | 指导教师 | 学生 | 企业管理员 | 企业导师 |
|---------|-----------|-----------|-----------|--------|---------|------|-----------|---------|
| **系统管理员** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| **学校管理员** | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| **学院负责人** | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ |
| **班主任** | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ❌ | ❌ |
| **企业管理员** | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ | ✅ |

**权限说明：**
- ✅ 表示可以编辑该角色的用户信息
- ❌ 表示不能编辑该角色的用户信息
- **系统管理员**：可以编辑所有用户信息
- **学校管理员**：可以编辑学校相关角色的用户信息，不能编辑系统管理员、企业相关角色的用户信息
- **学院负责人**：可以编辑教师相关角色和学生角色的用户信息，不能编辑系统管理员、学校管理员、企业相关角色的用户信息
- **班主任**：只能编辑学生角色的用户信息，不能编辑其他任何角色的用户信息
- **企业管理员**：只能编辑企业相关角色的用户信息，不能编辑其他任何角色的用户信息

#### 2.6.4 Controller层权限控制规范

##### 2.6.4.1 @PreAuthorize注解使用规范
- **必须使用`hasAnyRole`或`hasRole`**：禁止使用`hasAuthority`，统一使用角色进行权限控制
- **多角色权限**：使用`hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN')`表示多个角色都可以访问
- **单角色权限**：使用`hasRole('ROLE_SYSTEM_ADMIN')`表示只有该角色可以访问
- **权限表达式示例**：
  ```java
  // 正确示例：使用hasAnyRole
  @PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN')")
  
  // 错误示例：使用hasAuthority
  @PreAuthorize("hasAuthority('user:view')")  // ❌ 禁止使用
  ```

##### 2.6.4.2 不同操作的权限分配原则
- **查询操作**：根据业务需求，允许多个角色查询，如：`hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN', 'ROLE_ENTERPRISE_ADMIN')`
- **新增操作**：通常只允许系统管理员和对应的业务管理员，如：`hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN')`
- **编辑操作**：
  - **企业管理**：只允许系统管理员和企业管理员编辑（学校管理员只能查看）
  - **企业导师管理**：只允许系统管理员和企业管理员管理（学校管理员只能查看）
  - **其他业务**：根据业务需求分配权限
- **删除操作**：通常只允许系统管理员和对应的业务管理员

##### 2.6.4.3 权限控制示例
```java
// 企业管理Controller示例
@ApiOperation("分页查询企业列表")
@GetMapping("/page")
@PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_SCHOOL_ADMIN', 'ROLE_ENTERPRISE_ADMIN')")
public Result<Page<Enterprise>> getEnterprisePage(...) {
    // 查询操作：多个角色都可以查询
}

@ApiOperation("更新企业信息")
@PutMapping
@PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_ENTERPRISE_ADMIN')")
public Result<Enterprise> updateEnterprise(@RequestBody Enterprise enterprise) {
    // 编辑操作：只允许系统管理员和企业管理员（学校管理员不能编辑）
}

@ApiOperation("添加企业导师")
@PostMapping
@PreAuthorize("hasAnyRole('ROLE_SYSTEM_ADMIN', 'ROLE_ENTERPRISE_ADMIN')")
public Result<EnterpriseMentor> addEnterpriseMentor(...) {
    // 企业导师管理：只允许系统管理员和企业管理员（学校管理员不能管理）
}
```

#### 2.6.5 Service层数据权限过滤规范

##### 2.6.5.1 DataPermissionUtil工具类使用
- **注入方式**：在Service实现类中注入`DataPermissionUtil`
- **常用方法**：
  - `isSystemAdmin()`：判断是否为系统管理员
  - `getCurrentUserSchoolId()`：获取当前用户的学校ID
  - `getCurrentUserCollegeId()`：获取当前用户的学院ID
  - `getCurrentUserClassId()`：获取当前用户的班级ID
  - `getCurrentUserEnterpriseId()`：获取当前用户的企业ID
  - `getCooperationEnterpriseIds()`：获取当前用户有合作关系的企业ID列表
  - `canAssignRole(String roleCode)`：检查当前用户是否可以分配指定角色
  - `canEditUser(Long userId)`：检查当前用户是否可以编辑指定用户

##### 2.6.5.2 查询方法数据权限过滤
- **系统管理员**：不添加任何过滤条件，可以查询所有数据
- **其他角色**：根据角色自动添加对应的数据范围限制
- **实现示例**：
  ```java
  @Override
  public Page<Enterprise> getEnterprisePage(Page<Enterprise> page, ...) {
      LambdaQueryWrapper<Enterprise> wrapper = new LambdaQueryWrapper<>();
      wrapper.eq(Enterprise::getDeleteFlag, DeleteFlag.NORMAL.getCode());
      
      // 数据权限过滤
      if (!dataPermissionUtil.isSystemAdmin()) {
          String username = SecurityUtil.getCurrentUsername();
          UserInfo currentUser = userMapper.selectOne(...);
          if (currentUser != null) {
              List<String> roleCodes = userMapper.selectRoleCodesByUserId(currentUser.getUserId());
              // 企业管理员：只能查看本企业
              if (roleCodes.contains("ROLE_ENTERPRISE_ADMIN")) {
                  wrapper.eq(Enterprise::getUserId, currentUser.getUserId());
              } else {
                  // 学校管理员：只能查看有合作关系的企业
                  List<Long> cooperationEnterpriseIds = dataPermissionUtil.getCooperationEnterpriseIds();
                  if (cooperationEnterpriseIds != null) {
                      if (cooperationEnterpriseIds.isEmpty()) {
                          wrapper.eq(Enterprise::getEnterpriseId, -1L); // 返回空结果
                      } else {
                          wrapper.in(Enterprise::getEnterpriseId, cooperationEnterpriseIds);
                      }
                  }
              }
          }
      }
      return this.page(page, wrapper);
  }
  ```

##### 2.6.5.3 编辑/删除方法数据权限检查
- **必须进行权限检查**：编辑和删除操作必须在Service层进行数据权限检查
- **检查原则**：
  - 系统管理员：不限制
  - 企业管理员：只能编辑/删除自己企业的数据
  - 学校管理员：只能编辑/删除自己学校的数据（某些业务不允许编辑，如企业管理）
  - 其他角色：根据业务需求进行限制
- **实现示例**：
  ```java
  @Override
  @Transactional(rollbackFor = Exception.class)
  public Enterprise updateEnterprise(Enterprise enterprise) {
      // 检查企业是否存在
      Enterprise existEnterprise = this.getById(enterprise.getEnterpriseId());
      if (existEnterprise == null) {
          throw new BusinessException("企业不存在");
      }
      
      // 数据权限检查：只有系统管理员或企业管理员可以编辑企业信息
      // 企业管理员只能编辑自己的企业
      if (!dataPermissionUtil.isSystemAdmin()) {
          String username = SecurityUtil.getCurrentUsername();
          UserInfo currentUser = userMapper.selectOne(...);
          if (currentUser != null) {
              List<String> roleCodes = userMapper.selectRoleCodesByUserId(currentUser.getUserId());
              // 企业管理员：只能编辑本企业
              if (roleCodes.contains("ROLE_ENTERPRISE_ADMIN")) {
                  if (!existEnterprise.getUserId().equals(currentUser.getUserId())) {
                      throw new BusinessException("无权编辑该企业信息");
                  }
              } else {
                  // 其他角色（包括学校管理员）不能编辑企业信息
                  throw new BusinessException("无权编辑企业信息");
              }
          }
      }
      
      // 执行更新操作
      this.updateById(enterprise);
      return this.getById(enterprise.getEnterpriseId());
  }
  ```

##### 2.6.5.4 查询详情方法数据权限检查
- **必须进行权限检查**：查询详情操作也需要进行数据权限检查，防止越权访问
- **实现示例**：
  ```java
  @Override
  public Enterprise getEnterpriseById(Long enterpriseId) {
      Enterprise enterprise = this.getById(enterpriseId);
      if (enterprise == null) {
          throw new BusinessException("企业不存在");
      }
      
      // 数据权限检查：非系统管理员需要检查是否有权限查看该企业
      if (!dataPermissionUtil.isSystemAdmin()) {
          // 检查逻辑...
          if (!hasPermission) {
              throw new BusinessException("无权查看该企业信息");
          }
      }
      
      return enterprise;
  }
  ```

#### 2.6.6 特殊业务权限控制规则

##### 2.6.6.1 企业管理权限规则
- **查询权限**：系统管理员、学校管理员、企业管理员都可以查询
- **编辑权限**：只允许系统管理员和企业管理员编辑（企业管理员只能编辑自己的企业）
- **学校管理员权限**：只能查看有合作关系的企业，不能编辑企业信息
- **数据过滤**：学校管理员只能看到和本校有合作关系的企业

##### 2.6.6.2 企业导师管理权限规则
- **查询权限**：系统管理员、学校管理员、企业管理员都可以查询
- **管理权限**：只允许系统管理员和企业管理员添加/编辑/删除（企业管理员只能管理自己企业的导师）
- **学校管理员权限**：只能查看有合作关系的企业的导师，不能管理企业导师
- **数据过滤**：学校管理员只能看到和本校有合作关系的企业的导师

##### 2.6.6.3 合作关系管理权限规则
- **查询权限**：系统管理员、学校管理员、企业管理员都可以查询
- **管理权限**：系统管理员和学校管理员可以添加/编辑/删除合作关系
- **数据过滤**：
  - 学校管理员只能管理自己学校的合作关系
  - 学校管理员只能看到自己学校的合作关系列表
  - 添加/编辑/删除时检查学校ID是否属于当前用户

##### 2.6.6.4 学校列表权限规则
- **查询权限**：系统管理员、学校管理员都可以查询
- **数据过滤**：学校管理员只能看到自己的学校（用于添加学院/专业时的下拉选择）

##### 2.6.6.5 用户编辑权限规则
- **权限层级**：
  1. **系统管理员**：可以编辑所有用户
  2. **学校管理员**：不能编辑系统管理员，可以编辑其他所有用户
  3. **学院负责人**：不能编辑系统管理员、学校管理员，可以编辑教师、学生等
  4. **班主任**：不能编辑系统管理员、学校管理员、学院负责人，可以编辑学生等
- **实现方式**：
  - 后端：在 `UserServiceImpl.updateUser` 和 `TeacherServiceImpl.updateTeacher` 方法中使用 `DataPermissionUtil.canEditUser()` 进行权限检查
  - 前端：在用户列表和教师列表中，使用 `canEditUser()` 函数判断是否禁用编辑按钮
- **代码示例**：
  ```java
  // 后端权限检查
  if (!dataPermissionUtil.canEditUser(user.getUserId())) {
      throw new BusinessException("无权限编辑该用户信息");
  }
  ```
  ```javascript
  // 前端按钮禁用
  :disabled="!canEditUser(row.roles || [])"
  ```

##### 2.6.6.6 角色分配权限规则
- **权限层级**：
  1. **系统管理员**：可以分配所有角色
  2. **学校管理员**：不能分配系统管理员角色，可以分配其他角色
  3. **学院负责人**：不能分配系统管理员、学校管理员角色，可以分配教师、学生等角色
  4. **班主任**：不能分配系统管理员、学校管理员、学院负责人角色，可以分配学生角色
- **实现方式**：
  - 后端：在 `TeacherServiceImpl.addTeacherWithUser` 和 `updateTeacherWithUser` 方法中使用 `DataPermissionUtil.canAssignRole()` 进行权限检查
  - 前端：在添加/编辑教师时，使用 `canAssignRole()` 函数过滤角色下拉列表
- **代码示例**：
  ```java
  // 后端权限检查
  if (!dataPermissionUtil.canAssignRole(finalRoleCode)) {
      throw new BusinessException("无权限分配该角色：" + finalRoleCode);
  }
  ```
  ```javascript
  // 前端角色过滤
  const filteredRoleList = computed(() => {
    return roleList.value.filter(role => canAssignRole(role.roleCode))
  })
  ```

#### 2.6.7 数据权限过滤最佳实践

##### 2.6.7.1 查询方法过滤模式
```java
// 标准模式：先判断是否为系统管理员，再根据角色添加过滤条件
if (!dataPermissionUtil.isSystemAdmin()) {
    // 获取当前用户信息
    String username = SecurityUtil.getCurrentUsername();
    UserInfo currentUser = userMapper.selectOne(...);
    
    if (currentUser != null) {
        List<String> roleCodes = userMapper.selectRoleCodesByUserId(currentUser.getUserId());
        
        // 根据角色添加不同的过滤条件
        if (roleCodes.contains("ROLE_ENTERPRISE_ADMIN")) {
            // 企业管理员：只能查看本企业
            wrapper.eq(Entity::getEnterpriseId, currentUserEnterpriseId);
        } else if (roleCodes.contains("ROLE_SCHOOL_ADMIN")) {
            // 学校管理员：只能查看本校数据
            wrapper.eq(Entity::getSchoolId, currentUserSchoolId);
        } else {
            // 其他角色...
        }
    }
}
```

##### 2.6.7.2 编辑/删除方法检查模式
```java
// 标准模式：先检查数据是否存在，再检查权限
// 1. 检查数据是否存在
Entity existEntity = this.getById(entityId);
if (existEntity == null) {
    throw new BusinessException("数据不存在");
}

// 2. 数据权限检查
if (!dataPermissionUtil.isSystemAdmin()) {
    // 获取当前用户信息
    // 检查是否有权限操作该数据
    if (!hasPermission) {
        throw new BusinessException("无权操作该数据");
    }
}

// 3. 执行操作
this.updateById(entity);
```

##### 2.6.7.3 关联查询过滤模式
```java
// 对于需要通过关联表查询的场景，先查询关联ID列表，再过滤
// 例如：查询和本校有合作关系的企业
List<Long> cooperationEnterpriseIds = dataPermissionUtil.getCooperationEnterpriseIds();
if (cooperationEnterpriseIds != null) {
    if (cooperationEnterpriseIds.isEmpty()) {
        // 如果没有合作关系，返回空结果
        wrapper.eq(Enterprise::getEnterpriseId, -1L);
    } else {
        wrapper.in(Enterprise::getEnterpriseId, cooperationEnterpriseIds);
    }
}
```

#### 2.6.8 权限控制检查清单
开发新功能时，必须检查以下权限控制点：
- [ ] Controller方法是否添加了`@PreAuthorize`注解
- [ ] `@PreAuthorize`是否使用了`hasAnyRole`或`hasRole`（禁止使用`hasAuthority`）
- [ ] 查询方法是否在Service层添加了数据权限过滤
- [ ] 编辑/删除方法是否在Service层添加了数据权限检查
- [ ] 查询详情方法是否添加了数据权限检查
- [ ] 是否考虑了所有角色的权限需求
- [ ] 是否测试了不同角色的权限控制效果

#### 2.6.5 MyBatis Plus 查询规范（重要）
- **禁止使用 `inSql` 直接拼接 SQL 字符串**：存在 SQL 注入风险，且不符合 MyBatis Plus 最佳实践
- **推荐做法**：
  1. 先通过 Mapper 查询获取 ID 列表
  2. 使用 `wrapper.in(字段, ID列表)` 方法进行查询
  3. 如果查询结果为空，应设置无效条件（如 `wrapper.eq(字段, -1L)`）返回空结果
- **示例**：
  ```java
  // ❌ 错误做法：直接拼接 SQL
  wrapper.inSql(UserInfo::getUserId, 
          "SELECT user_id FROM student_info WHERE class_id = " + classId + " AND delete_flag = 0");
  
  // ✅ 正确做法：先查询 ID 列表，再使用 in 方法
  List<Student> students = studentMapper.selectList(
          new LambdaQueryWrapper<Student>()
                  .eq(Student::getClassId, classId)
                  .eq(Student::getDeleteFlag, DeleteFlag.NORMAL.getCode())
                  .select(Student::getUserId)
  );
  if (students != null && !students.isEmpty()) {
      List<Long> userIds = students.stream()
              .map(Student::getUserId)
              .collect(Collectors.toList());
      wrapper.in(UserInfo::getUserId, userIds);
  } else {
      wrapper.eq(UserInfo::getUserId, -1L); // 返回空结果
  }
  ```
- **注意事项**：
  - 对于关联查询，应分步查询：先查询关联表的 ID 列表，再查询主表
  - 使用 `select()` 方法只查询需要的字段，提高查询效率
  - 对于 UNION 查询场景，应分别查询各表，然后在内存中合并 ID 列表

### 2.7 JWT认证规范

#### 2.7.1 JWT配置要求
- Token过期时间：建议设置为2小时
- Refresh Token过期时间：建议设置为7天
- Token密钥：使用强随机字符串，长度不少于32位
- Token存储：Redis存储，Key格式：`jwt:token:{userId}`

#### 2.7.2 JWT工具类规范
- 提供生成Token方法：`generateToken(UserDetails userDetails)`
- 提供验证Token方法：`validateToken(String token)`
- 提供获取用户信息方法：`getUserFromToken(String token)`
- 提供刷新Token方法：`refreshToken(String token)`

#### 2.7.3 JWT过滤器规范
- 实现`OncePerRequestFilter`接口
- 从请求头获取Token：`Authorization: Bearer {token}`
- Token验证失败返回401状态码
- Token验证成功将用户信息存入SecurityContext

### 2.8 Redis使用规范

#### 2.8.1 Redis Key命名规范
- 统一使用冒号分隔，格式：`模块:功能:标识`
- 示例：
  - Token存储：`jwt:token:{userId}`
  - 用户信息缓存：`user:info:{userId}`
  - 验证码：`captcha:login:{sessionId}`
  - 班级分享码：`class:share_code:{classId}`

#### 2.8.2 Redis使用场景
- **Token存储**：存储JWT Token，支持Token刷新和注销
- **用户信息缓存**：缓存用户基本信息，减少数据库查询
- **验证码存储**：存储登录验证码、注册验证码等
- **权限信息缓存**：缓存用户权限信息，提高权限校验效率
- **班级分享码缓存**：缓存班级分享码及其过期时间

#### 2.8.3 Redis工具类规范
- 提供通用的`get`、`set`、`delete`方法
- 提供带过期时间的`set`方法
- 提供`exists`、`expire`等方法
- 所有方法必须处理异常情况

### 2.9 文件上传规范

#### 2.9.1 文件上传接口规范
- **接口路径**：`/file/upload`（多文件）和`/file/upload/single`（单文件）
- **请求方式**：POST
- **请求参数**：`MultipartFile`或`MultipartFile[]`
- **响应格式**：返回文件URL列表（多文件）或单个文件URL（单文件）
- **权限控制**：所有已登录用户都可以上传文件

#### 2.9.2 文件类型限制
- **支持的文件类型**：
  - 文档类型：`.doc`, `.docx`, `.pdf`, `.txt`, `.rtf`
  - 图片类型：`.jpg`, `.jpeg`, `.png`, `.gif`, `.bmp`
  - 表格类型：`.xls`, `.xlsx`
  - 压缩文件：`.zip`, `.rar`, `.7z`
- **文件大小限制**：单个文件最大10MB（可在`application.yml`中配置）

#### 2.9.3 文件存储规范
- **存储路径**：`uploads/yyyy/MM/dd/`（按日期分类）
- **文件命名**：使用UUID生成唯一文件名，保留原始扩展名
- **文件URL格式**：`/uploads/yyyy/MM/dd/{uuid}.{ext}`
- **静态资源访问**：配置`WebMvcConfig`映射`/uploads/**`到文件系统

#### 2.9.4 文件上传实现示例
```java
@PostMapping("/upload")
@PreAuthorize("hasAnyRole('ROLE_STUDENT', 'ROLE_TEACHER')")
public Result<List<String>> uploadFiles(@RequestParam("files") MultipartFile[] files) {
    // 1. 验证文件（类型、大小）
    // 2. 生成文件名（UUID）
    // 3. 创建存储目录（按日期）
    // 4. 保存文件
    // 5. 返回文件URL列表
}
```

#### 2.9.5 附件字段存储规范
- **数据库字段**：使用`VARCHAR`或`TEXT`类型存储附件URL
- **多附件存储**：多个附件URL用逗号分隔，如：`/uploads/2024/01/01/file1.pdf,/uploads/2024/01/01/file2.docx`
- **附件字段命名**：统一使用`attachment_urls`或`{业务}_attachment_urls`

### 2.10 异常处理规范

#### 2.10.1 异常分类
- **业务异常**：`BusinessException`，用于业务逻辑错误
- **参数异常**：`ParameterException`，用于参数校验错误
- **权限异常**：`AccessDeniedException`，用于权限不足
- **系统异常**：`SystemException`，用于系统错误

#### 2.10.2 全局异常处理
- 使用`@ControllerAdvice`创建全局异常处理器
- 统一异常响应格式，使用`Result`封装
- 记录异常日志，便于问题排查
- 不同异常返回不同的HTTP状态码

#### 2.9.3 异常处理示例
- 业务异常：返回200状态码，Result中code为业务错误码
- 参数异常：返回400状态码
- 权限异常：返回403状态码
- 系统异常：返回500状态码

### 2.10 统一响应结果规范

#### 2.10.1 Result类结构
```java
Result {
    code: 响应码（成功：200，失败：其他）
    message: 响应消息
    data: 响应数据
    timestamp: 响应时间戳
}
```

#### 2.10.2 响应码定义
- **200**：操作成功
- **400**：参数错误
- **401**：未认证
- **403**：无权限
- **404**：资源不存在
- **500**：服务器错误
- **业务错误码**：1000-9999，根据业务模块定义

### 2.11 代码注释规范

#### 2.11.1 类注释
- 所有类必须添加类注释，说明类的功能和用途
- 类注释只包含类描述，不包含作者和日期信息
- 示例：
  ```java
  /**
   * 统一响应结果封装
   */
  ```

#### 2.11.2 方法注释
- 所有public方法必须添加JavaDoc注释
- 方法注释包含：方法描述、参数说明、返回值说明、异常说明

#### 2.11.3 字段注释
- 实体类字段必须添加`@ApiModelProperty`注解说明
- 复杂业务字段必须添加行内注释

### 2.12 数据库设计规范

#### 2.12.0 数据库版本要求
- **数据库版本**：MySQL 8.0及以上版本
- **字符集**：统一使用`utf8mb4`字符集，支持完整的UTF-8编码（包括emoji等特殊字符）
- **排序规则**：使用`utf8mb4_unicode_ci`排序规则
- **时区设置**：建议使用`Asia/Shanghai`时区
- **存储引擎**：统一使用`InnoDB`存储引擎，支持事务和外键约束

#### 2.12.1 表命名规范
- 表名使用小写字母和下划线，如：`school_info`、`student_info`
- 表名必须体现业务含义，避免使用缩写

#### 2.12.2 字段命名规范
- 字段名使用小写字母和下划线，如：`school_id`、`create_time`
- 主键统一命名为：`{表名}_id`，如：`school_id`
- 外键统一命名为：`{关联表名}_id`，如：`school_id`
- 时间字段统一命名为：`create_time`、`update_time`、`delete_time`

#### 2.12.3 字段类型规范
- **主键**：使用`VARCHAR(32)`或`BIGINT`，推荐使用`BIGINT`自增主键
- **字符串**：根据实际长度选择`VARCHAR`，避免使用`TEXT`，MySQL 8支持`VARCHAR(65535)`长度
- **数值**：根据范围选择`INT`、`BIGINT`、`DECIMAL`，精确数值使用`DECIMAL`
- **时间**：使用`DATETIME`类型，MySQL 8支持微秒精度（`DATETIME(6)`）
- **布尔**：使用`TINYINT(1)`，0表示false，1表示true，或使用`BOOLEAN`类型（MySQL 8支持）
- **JSON**：MySQL 8支持原生JSON类型，可用于存储结构化数据

#### 2.12.4 索引规范
- 主键必须创建主键索引
- 外键字段必须创建索引
- 查询频繁的字段创建索引
- 唯一性约束字段创建唯一索引

#### 2.12.5 软删除规范
- 所有业务表必须添加`delete_flag`字段，类型为`TINYINT(1)`
- `delete_flag = 0`表示未删除，`delete_flag = 1`表示已删除
- 所有查询必须过滤已删除数据
- 删除操作只更新`delete_flag`字段，不物理删除

