# 学生实习状态转换与页面显示设计文档

## 一、背景说明

### 1.1 问题场景

学生在实习过程中可能发生以下状态转换：

1. **合作企业 → 合作企业**：从合作企业A离职，申请合作企业B的岗位并通过
2. **自主实习 → 合作企业**：从自主实习公司离职，申请合作企业的岗位并通过
3. **合作企业 → 自主实习**：从合作企业离职，申请自主实习并审核通过
4. **自主实习 → 自主实习**：从自主实习公司A离职，申请自主实习公司B并审核通过

### 1.2 核心问题

- 状态转换时，`student` 表的 `current_apply_id`、`current_enterprise_id`、`internship_status` 如何更新？
- 不同页面的状态显示如何联动？
- 历史实习记录如何保存和显示？
- 数据一致性如何保证？

## 二、数据模型设计

### 2.1 Student 表字段

```sql
-- 学生当前实习状态字段
current_apply_id          BIGINT      -- 当前实习申请ID（指向最新的已确认上岗的申请）
current_enterprise_id     BIGINT      -- 当前企业ID（仅合作企业实习有值）
internship_status         TINYINT     -- 实习状态：0-未实习，1-实习中，3-已结束
```

### 2.2 InternshipApply 表字段

```sql
-- 实习申请状态字段
status                    TINYINT     -- 申请状态：0-待审核，1-已通过，2-已拒绝，3-已录用，4-已拒绝录用，5-已取消
student_confirm_status    TINYINT     -- 学生确认状态：0-待确认，1-已确认上岗
unbind_status            TINYINT     -- 解绑状态：0-未解绑，2-已解绑
apply_type               TINYINT     -- 申请类型：1-合作企业，2-自主实习
```

## 三、状态转换流程设计

### 3.1 场景一：合作企业 → 合作企业

#### 流程说明

```
学生A在合作企业A实习（已确认上岗）
  ↓
学生点击"离职"按钮，调用解绑接口
  ↓
后端更新：
  - InternshipApply.unbind_status = 2（已解绑）
  - Student.current_apply_id = NULL
  - Student.current_enterprise_id = NULL
  - Student.internship_status = 0（未实习）
  ↓
学生申请合作企业B的岗位
  ↓
企业B审核通过，状态变为"已录用"（status = 3）
  ↓
学生确认上岗
  ↓
后端更新：
  - InternshipApply.student_confirm_status = 1（已确认上岗）
  - Student.current_apply_id = 新申请ID
  - Student.current_enterprise_id = 企业B的ID
  - Student.internship_status = 1（实习中）
```

#### 关键代码逻辑

**解绑时：**
```java
// InternshipApplyServiceImpl.unbindInternship()
apply.setUnbindStatus(UnbindStatus.UNBOUND.getCode());
this.updateById(apply);

// 更新学生状态
Student student = studentMapper.selectById(apply.getStudentId());
if (student.getCurrentApplyId() != null && student.getCurrentApplyId().equals(apply.getApplyId())) {
    student.setCurrentApplyId(null);
    student.setCurrentEnterpriseId(null);
    student.setInternshipStatus(StudentInternshipStatus.NOT_STARTED.getCode());
    studentMapper.updateById(student);
}
```

**确认上岗时：**
```java
// InternshipApplyServiceImpl.confirmOnboard()
apply.setStudentConfirmStatus(StudentConfirmStatus.CONFIRMED.getCode());
apply.setStudentConfirmTime(LocalDateTime.now());
this.updateById(apply);

// 更新学生状态
Student student = studentMapper.selectById(apply.getStudentId());
student.setCurrentApplyId(apply.getApplyId());
if (apply.getApplyType().equals(ApplyType.COOPERATION.getCode())) {
    student.setCurrentEnterpriseId(apply.getEnterpriseId());
} else {
    student.setCurrentEnterpriseId(null);
}
student.setInternshipStatus(StudentInternshipStatus.IN_PROGRESS.getCode());
studentMapper.updateById(student);
```

### 3.2 场景二：自主实习 → 合作企业

#### 流程说明

```
学生A在自主实习公司A实习（已确认上岗）
  ↓
学生点击"离职"按钮，调用解绑接口
  ↓
后端更新：
  - InternshipApply.unbind_status = 2（已解绑）
  - Student.current_apply_id = NULL
  - Student.current_enterprise_id = NULL（本来就是NULL）
  - Student.internship_status = 0（未实习）
  ↓
学生申请合作企业B的岗位
  ↓
企业B审核通过，状态变为"已录用"（status = 3）
  ↓
学生确认上岗
  ↓
后端更新：
  - InternshipApply.student_confirm_status = 1（已确认上岗）
  - Student.current_apply_id = 新申请ID
  - Student.current_enterprise_id = 企业B的ID
  - Student.internship_status = 1（实习中）
```

### 3.3 场景三：合作企业 → 自主实习

#### 流程说明

```
学生A在合作企业A实习（已确认上岗）
  ↓
学生点击"离职"按钮，调用解绑接口
  ↓
后端更新：
  - InternshipApply.unbind_status = 2（已解绑）
  - Student.current_apply_id = NULL
  - Student.current_enterprise_id = NULL
  - Student.internship_status = 0（未实习）
  ↓
学生申请自主实习
  ↓
班主任审核通过
  ↓
后端自动处理（processSelfApplyApproved）：
  - 创建或查找企业并绑定（apply.enterprise_id）
  - InternshipApply.status = 3（已录用）
  - InternshipApply.student_confirm_status = 1（已确认上岗，自动确认）
  - InternshipApply.student_confirm_time = 当前时间
  - Student.current_apply_id = 新申请ID
  - Student.current_enterprise_id = 创建的企业ID（自主实习也会创建企业记录）
  - Student.internship_status = 1（实习中）
  ↓
学生无需手动确认上岗，审核通过即开始实习
```

### 3.4 场景四：自主实习 → 自主实习

#### 流程说明

```
学生A在自主实习公司A实习（已确认上岗）
  ↓
学生点击"离职"按钮，调用解绑接口
  ↓
后端更新：
  - InternshipApply.unbind_status = 2（已解绑）
  - Student.current_apply_id = NULL
  - Student.current_enterprise_id = NULL
  - Student.internship_status = 0（未实习）
  ↓
学生申请自主实习公司B
  ↓
班主任审核通过
  ↓
后端自动处理（processSelfApplyApproved）：
  - 创建或查找企业并绑定（apply.enterprise_id）
  - InternshipApply.status = 3（已录用）
  - InternshipApply.student_confirm_status = 1（已确认上岗，自动确认）
  - InternshipApply.student_confirm_time = 当前时间
  - Student.current_apply_id = 新申请ID
  - Student.current_enterprise_id = 创建的企业ID
  - Student.internship_status = 1（实习中）
  ↓
学生无需手动确认上岗，审核通过即开始实习
```

## 四、页面显示设计

### 4.1 "我的实习"页面（学生端）

#### 显示逻辑

```javascript
// 1. 查询当前实习信息
const currentInternship = await applyApi.getCurrentInternship()

// 后端逻辑：getCurrentInternship()
// - 查询 Student.current_apply_id 对应的 InternshipApply
// - 如果 current_apply_id 为 NULL，返回 null
// - 如果对应的申请 unbind_status = 2，返回 null（已解绑的不算当前实习）

// 2. 页面显示
if (!currentInternship) {
  // 显示"您当前没有正在进行的实习"
  // 显示"去申请实习"按钮
} else {
  // 显示当前实习信息
  // 显示"离职"按钮（如果未解绑）
  // 显示"导出实习报告"按钮（仅合作企业实习）
}
```

#### 状态标签显示

```javascript
// 实习状态标签
<el-tag :type="getInternshipStatusType(currentInternship.studentInternshipStatus)">
  {{ getInternshipStatusText(currentInternship.studentInternshipStatus) }}
</el-tag>
// 0-未实习 → "未实习"（灰色）
// 1-实习中 → "实习中"（绿色）
// 3-已结束 → "已结束"（灰色）

// 确认状态标签
<el-tag v-if="currentInternship.studentConfirmStatus === 1 && unbindStatus !== 2" type="success">
  已确认上岗
</el-tag>
<el-tag v-else-if="currentInternship.studentConfirmStatus === 0 && unbindStatus !== 2" type="warning">
  待确认上岗
</el-tag>
```

### 4.2 "实习申请"页面（学生端）

#### 显示逻辑

```javascript
// 查询所有实习申请（包括历史申请）
const applyList = await applyApi.getApplyPage({
  studentId: currentStudentId
})

// 显示所有申请，包括：
// - 当前实习申请（current_apply_id 对应的）
// - 历史实习申请（已解绑的）
// - 待审核的申请
// - 已拒绝的申请
```

#### 状态显示

```javascript
// 申请状态
<el-tag :type="getApplyStatusType(row.status, row.statusText)">
  {{ row.statusText || getApplyStatusText(row.status) }}
</el-tag>

// 在职状态
<el-tag v-if="row.unbindStatus === 2" type="danger">离职</el-tag>
<el-tag v-else-if="row.applyId === currentApplyId" type="success">在职</el-tag>
<el-tag v-else type="info">未上岗</el-tag>
```

### 4.3 "实习申请审核"页面（管理员/班主任端）

#### 显示逻辑

```javascript
// 查询所有学生的实习申请
const applyList = await applyApi.getApplyPage({
  // 管理员可以查看所有申请
  // 班主任只能查看所管理班级学生的申请
})

// 显示所有申请，包括：
// - 当前实习申请
// - 历史实习申请（已解绑的）
// - 待审核的申请
```

#### 状态显示

```javascript
// 申请类型
<el-tag :type="row.applyType === 1 ? 'primary' : 'warning'">
  {{ row.applyType === 1 ? '合作企业' : '自主实习' }}
</el-tag>

// 申请状态
<el-tag :type="getStatusType(row.status, row.statusText)">
  {{ row.statusText || getStatusText(row.status) }}
</el-tag>

// 在职状态
<el-tag v-if="row.unbindStatus === 2" type="danger">离职</el-tag>
<el-tag v-else type="success">在职</el-tag>
```

### 4.4 "学生管理"页面（管理员端）

#### 显示逻辑

```javascript
// 查询所有学生
const studentList = await studentApi.getStudentPage({})

// 显示学生当前实习状态
<el-tag :type="getInternshipStatusType(row.internshipStatus)">
  {{ getInternshipStatusText(row.internshipStatus) }}
</el-tag>
// 0-未实习 → "未实习"（灰色）
// 1-实习中 → "实习中"（绿色）
// 3-已结束 → "已结束"（灰色）

// 显示当前实习企业
<span v-if="row.currentEnterpriseId">
  {{ getEnterpriseName(row.currentEnterpriseId) }}
</span>
<span v-else-if="row.currentApplyId">
  {{ getSelfEnterpriseName(row.currentApplyId) }}
</span>
<span v-else>-</span>
```

### 4.5 "学生管理"页面（企业导师端）

#### 显示逻辑

```javascript
// 查询企业导师指导的学生列表
const studentList = await applyApi.getMentorStudents({})

// 只显示当前实习状态为"实习中"且未解绑的学生
// 后端已过滤：只返回 applyType = 1（合作企业）且 unbind_status != 2 的学生
```

## 五、状态联动设计

### 5.1 解绑时的状态联动

#### 后端逻辑

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void unbindInternship(Long applyId, String reason, String remark) {
    // 1. 更新申请状态
    InternshipApply apply = this.getById(applyId);
    EntityValidationUtil.validateEntityExists(apply, "申请");
    
    // 验证：只有已确认上岗的申请才能解绑
    if (apply.getStudentConfirmStatus() == null || 
        !apply.getStudentConfirmStatus().equals(StudentConfirmStatus.CONFIRMED.getCode())) {
        throw new BusinessException("只有已确认上岗的申请才能解绑");
    }
    
    // 验证：已经解绑的不能重复解绑
    if (apply.getUnbindStatus() != null && 
        apply.getUnbindStatus().equals(UnbindStatus.UNBOUND.getCode())) {
        throw new BusinessException("该申请已经解绑");
    }
    
    // 更新解绑状态
    apply.setUnbindStatus(UnbindStatus.UNBOUND.getCode());
    apply.setUnbindReason(reason);
    apply.setUnbindAuditOpinion(remark);
    apply.setUnbindAuditTime(LocalDateTime.now());
    this.updateById(apply);
    
    // 2. 更新学生状态（如果这是当前实习）
    Student student = studentMapper.selectById(apply.getStudentId());
    if (student.getCurrentApplyId() != null && 
        student.getCurrentApplyId().equals(applyId)) {
        student.setCurrentApplyId(null);
        student.setCurrentEnterpriseId(null);
        student.setInternshipStatus(StudentInternshipStatus.NOT_STARTED.getCode());
        studentMapper.updateById(student);
    }
}
```

#### 前端联动

```javascript
// 解绑成功后，重新加载相关页面数据
const handleSubmitUnbind = async () => {
  // ... 调用解绑接口
  if (res.code === 200) {
    ElMessage.success('解绑成功')
    
    // 如果是学生端，重新加载"我的实习"页面
    if (isStudentPage) {
      await loadCurrentInternship() // 重新加载当前实习信息
    }
    
    // 如果是管理员端，重新加载申请列表
    if (isAdminPage) {
      await loadData() // 重新加载申请列表
    }
  }
}
```

### 5.2 确认上岗时的状态联动

#### 后端逻辑

```java
@Override
@Transactional(rollbackFor = Exception.class)
public InternshipApply confirmOnboard(Long applyId) {
    InternshipApply apply = this.getById(applyId);
    EntityValidationUtil.validateEntityExists(apply, "申请");
    
    // 验证：只有已录用（合作企业）或已通过（自主实习）的申请才能确认上岗
    if (apply.getApplyType().equals(ApplyType.COOPERATION.getCode())) {
        if (apply.getStatus() == null || 
            !apply.getStatus().equals(InternshipApplyStatus.ACCEPTED.getCode())) {
            throw new BusinessException("只有已录用的申请才能确认上岗");
        }
    } else if (apply.getApplyType().equals(ApplyType.SELF.getCode())) {
        if (apply.getStatus() == null || 
            !apply.getStatus().equals(InternshipApplyStatus.APPROVED.getCode())) {
            throw new BusinessException("只有已通过的申请才能确认上岗");
        }
    }
    
    // 验证：已经确认上岗的不能重复确认
    if (apply.getStudentConfirmStatus() != null && 
        apply.getStudentConfirmStatus().equals(StudentConfirmStatus.CONFIRMED.getCode())) {
        throw new BusinessException("该申请已经确认上岗");
    }
    
    // 验证：已解绑的不能确认上岗
    if (apply.getUnbindStatus() != null && 
        apply.getUnbindStatus().equals(UnbindStatus.UNBOUND.getCode())) {
        throw new BusinessException("该申请已解绑，无法确认上岗");
    }
    
    // 更新申请状态
    apply.setStudentConfirmStatus(StudentConfirmStatus.CONFIRMED.getCode());
    apply.setStudentConfirmTime(LocalDateTime.now());
    this.updateById(apply);
    
    // 更新学生状态
    Student student = studentMapper.selectById(apply.getStudentId());
    
    // 如果学生之前有当前实习，先解绑（理论上不应该发生，但为了数据一致性）
    if (student.getCurrentApplyId() != null && 
        !student.getCurrentApplyId().equals(applyId)) {
        // 将之前的申请标记为已解绑（可选，或者保留历史记录）
        // 这里选择保留历史记录，不自动解绑之前的申请
    }
    
    // 设置新的当前实习
    student.setCurrentApplyId(applyId);
    if (apply.getApplyType().equals(ApplyType.COOPERATION.getCode())) {
        student.setCurrentEnterpriseId(apply.getEnterpriseId());
    } else {
        student.setCurrentEnterpriseId(null);
    }
    student.setInternshipStatus(StudentInternshipStatus.IN_PROGRESS.getCode());
    studentMapper.updateById(student);
    
    return apply;
}
```

#### 前端联动

```javascript
// 确认上岗成功后，重新加载相关页面数据
const handleConfirmOnboard = async (row) => {
  // ... 调用确认上岗接口
  if (res.code === 200) {
    ElMessage.success('确认上岗成功')
    
    // 重新加载"我的实习"页面
    await loadCurrentInternship()
    
    // 重新加载申请列表
    await loadApplyList()
  }
}
```

### 5.3 审核通过时的状态联动

#### 后端逻辑

```java
// 自主实习审核通过后，自动更新学生状态（如果学生确认上岗）
@Override
@Transactional(rollbackFor = Exception.class)
public InternshipApply auditApply(Long applyId, Integer auditStatus, String auditOpinion) {
    // ... 审核逻辑
    
    if (auditStatus.equals(InternshipApplyStatus.APPROVED.getCode())) {
        // 审核通过
        apply.setStatus(InternshipApplyStatus.APPROVED.getCode());
        apply.setAuditUserId(currentUserId);
        apply.setAuditTime(LocalDateTime.now());
        apply.setAuditOpinion(auditOpinion);
        this.updateById(apply);
        
        // 如果是自主实习，审核通过后，学生需要确认上岗
        // 这里不自动更新学生状态，等待学生确认上岗
    }
    
    return apply;
}
```

## 六、数据一致性保证

### 6.1 唯一性约束

- **一个学生同时只能有一个"当前实习"**：通过 `Student.current_apply_id` 保证
- **确认上岗时，自动更新 `current_apply_id`**：确保数据一致性

### 6.2 状态验证

- **解绑时验证**：只有已确认上岗的申请才能解绑
- **确认上岗时验证**：只有已录用（合作企业）或已通过（自主实习）的申请才能确认上岗
- **已解绑的申请不能再次确认上岗**

### 6.3 历史记录保留

- **已解绑的申请保留在数据库中**：`unbind_status = 2`
- **查询当前实习时过滤已解绑的申请**：`getCurrentInternship()` 方法中过滤
- **历史申请可以在"实习申请"页面查看**

## 七、页面显示规则总结

### 7.1 "我的实习"页面

| 条件 | 显示内容 |
|------|---------|
| `current_apply_id` 为 NULL | "您当前没有正在进行的实习" + "去申请实习"按钮 |
| `current_apply_id` 不为 NULL 且 `unbind_status != 2` | 显示当前实习信息 + "离职"按钮 + "导出实习报告"按钮（仅合作企业） |
| `current_apply_id` 不为 NULL 但 `unbind_status = 2` | "您当前没有正在进行的实习"（已解绑的不算当前实习） |

### 7.2 "实习申请"页面

| 申请状态 | 在职状态显示 |
|---------|------------|
| `unbind_status = 2` | "离职"（红色） |
| `applyId === current_apply_id` | "在职"（绿色） |
| 其他 | "未上岗"（灰色） |

### 7.3 "实习申请审核"页面

| 申请状态 | 在职状态显示 |
|---------|------------|
| `unbind_status = 2` | "离职"（红色） |
| `unbind_status != 2` | "在职"（绿色） |

### 7.4 "学生管理"页面

| 学生状态 | 显示内容 |
|---------|---------|
| `internship_status = 0` | "未实习"（灰色） |
| `internship_status = 1` | "实习中"（绿色）+ 企业名称 |
| `internship_status = 3` | "已结束"（灰色） |

## 八、待优化点

### 8.1 多实习申请处理

**问题**：学生是否可以同时申请多个实习？

**当前设计**：允许同时申请多个，但只能有一个"当前实习"

**建议**：
- 如果学生已有"当前实习"（未解绑），申请新实习时给出提示
- 或者：允许申请，但确认新实习时，自动解绑旧实习（需要确认）

### 8.2 实习结束状态

**问题**：实习结束后，`internship_status` 如何更新？

**当前设计**：需要手动更新或根据实习结束日期自动更新

**建议**：
- 添加定时任务，检查实习结束日期，自动更新状态
- 或者：在"我的实习"页面添加"结束实习"按钮

### 8.3 历史实习记录查询

**问题**：如何查看学生的历史实习记录？

**当前设计**：在"实习申请"页面可以查看所有申请（包括已解绑的）

**建议**：
- 添加"历史实习"页面，专门展示已解绑的实习记录
- 添加实习统计功能（实习次数、总时长等）

## 九、测试场景

### 9.1 场景一：合作企业 → 合作企业

1. 学生A在合作企业A实习（已确认上岗）
2. 学生A点击"离职"按钮
3. 验证：`current_apply_id` 为 NULL，`internship_status = 0`
4. 学生A申请合作企业B的岗位
5. 企业B审核通过，学生A确认上岗
6. 验证：`current_apply_id` 为新申请ID，`internship_status = 1`

### 9.2 场景二：自主实习 → 合作企业

1. 学生A在自主实习公司A实习（已确认上岗）
2. 学生A点击"离职"按钮
3. 验证：`current_apply_id` 为 NULL，`internship_status = 0`
4. 学生A申请合作企业B的岗位
5. 企业B审核通过，学生A确认上岗
6. 验证：`current_apply_id` 为新申请ID，`current_enterprise_id` 为企业B的ID

### 9.3 场景三：合作企业 → 自主实习

1. 学生A在合作企业A实习（已确认上岗）
2. 学生A点击"离职"按钮
3. 验证：`current_apply_id` 为 NULL，`current_enterprise_id` 为 NULL
4. 学生A申请自主实习
5. 班主任审核通过，学生A确认上岗
6. 验证：`current_apply_id` 为新申请ID，`current_enterprise_id` 为 NULL

### 9.4 场景四：自主实习 → 自主实习

1. 学生A在自主实习公司A实习（已确认上岗）
2. 学生A点击"离职"按钮
3. 验证：`current_apply_id` 为 NULL
4. 学生A申请自主实习公司B
5. 班主任审核通过，学生A确认上岗
6. 验证：`current_apply_id` 为新申请ID

## 十、当前代码实现情况

### 10.1 已实现的功能

1. ✅ **解绑功能**：`unbindInternship()` 方法已实现
   - 更新申请解绑状态
   - 更新学生状态（清空 `current_apply_id`）
   - 更新面试记录

2. ✅ **确认上岗功能**：`confirmOnboard()` 方法已实现
   - 验证申请状态
   - 检查是否有其他已确认的申请
   - 更新申请和学生状态

3. ✅ **查询当前实习**：`getCurrentInternship()` 方法已实现
   - 根据 `current_apply_id` 查询
   - 过滤已解绑的申请
   - 验证学生实习状态

### 10.2 重要说明：自主实习不需要确认上岗

**关键发现**：自主实习审核通过后，系统会自动处理，**不需要学生手动确认上岗**。

**当前实现逻辑：**
```java
// processSelfApplyApproved() 方法
private void processSelfApplyApproved(InternshipApply apply) {
    // 1. 创建或查找企业并绑定
    Long enterpriseId = findOrCreateEnterprise(apply);
    apply.setEnterpriseId(enterpriseId);
    apply.setStatus(InternshipApplyStatus.ACCEPTED.getCode()); // 状态自动变为已录用
    
    // 2. 自动更新学生信息
    updateStudentForSelfApplyApproved(apply);
    
    // 3. 自动设置学生确认状态为已确认
    apply.setStudentConfirmStatus(StudentConfirmStatus.CONFIRMED.getCode());
    apply.setStudentConfirmTime(LocalDateTime.now());
}
```

**流程对比：**

| 申请类型 | 审核通过后 | 学生确认上岗 |
|---------|-----------|------------|
| **合作企业** | 状态变为 `APPROVED`（已通过），等待企业处理 | ✅ **需要**：企业录用后（`ACCEPTED`），学生需要确认上岗 |
| **自主实习** | 状态自动变为 `ACCEPTED`（已录用），自动确认上岗 | ❌ **不需要**：审核通过即视为已确认上岗 |

### 10.3 需要修复的问题

#### 问题1：解绑时状态验证不完整

**当前代码：**
```java
// 验证申请状态
if (!apply.getStatus().equals(InternshipApplyStatus.ACCEPTED.getCode())) {
    throw new BusinessException("只有已录用的申请才能解绑");
}
```

**问题**：只检查了 `ACCEPTED`（已录用）状态。虽然自主实习审核通过后也会变为 `ACCEPTED`，但为了代码清晰，应该明确区分。

**修复方案：**
```java
// 验证申请状态
// 注意：自主实习审核通过后也会变为 ACCEPTED，所以这里可以统一检查 ACCEPTED
// 但需要确保申请已经确认上岗（student_confirm_status = 1）
if (!apply.getStatus().equals(InternshipApplyStatus.ACCEPTED.getCode())) {
    throw new BusinessException("只有已录用的申请才能解绑");
}

// 验证是否已确认上岗
if (apply.getStudentConfirmStatus() == null || 
    !apply.getStudentConfirmStatus().equals(StudentConfirmStatus.CONFIRMED.getCode())) {
    throw new BusinessException("只有已确认上岗的申请才能解绑");
}
```

#### 问题2：确认上岗方法应该禁止自主实习调用

**当前代码：**
```java
public boolean confirmOnboard(Long applyId) {
    // ... 验证逻辑
    validateConfirmOnboardStatus(apply);
    // ...
}
```

**问题**：自主实习不需要确认上岗，但 `confirmOnboard()` 方法没有禁止自主实习调用。

**修复方案：**
```java
private void validateConfirmOnboardStatus(InternshipApply apply) {
    // 自主实习不需要确认上岗（审核通过后自动确认）
    if (apply.getApplyType() != null && apply.getApplyType().equals(ApplyType.SELF.getCode())) {
        throw new BusinessException("自主实习审核通过后自动确认上岗，无需手动确认");
    }
    
    // 合作企业：必须是已录用状态
    EntityValidationUtil.validateStatusEquals(apply, InternshipApplyStatus.ACCEPTED.getCode(), 
            "申请", "只有已录用的申请才能确认上岗");
    // ...
}
```

#### 问题3：确认上岗时企业ID验证（已修复）

**当前代码：**
```java
private void updateStudentForConfirmOnboard(Student student, InternshipApply apply, Long applyId) {
    student.setCurrentApplyId(applyId);
    
    if (apply.getEnterpriseId() == null) {
        throw new BusinessException("申请的企业信息不完整，无法确认上岗，请联系管理员");
    }
    
    student.setCurrentEnterpriseId(apply.getEnterpriseId());
    student.setInternshipStatus(StudentInternshipStatus.IN_PROGRESS.getCode());
    studentMapper.updateById(student);
}
```

**说明**：由于自主实习不会调用 `confirmOnboard()` 方法（见问题2），所以这里的验证是合理的。但为了代码健壮性，可以添加类型检查：

**优化方案：**
```java
private void updateStudentForConfirmOnboard(Student student, InternshipApply apply, Long applyId) {
    student.setCurrentApplyId(applyId);
    
    // 确认上岗只用于合作企业，所以 enterpriseId 必须存在
    if (apply.getEnterpriseId() == null) {
        throw new BusinessException("申请的企业信息不完整，无法确认上岗，请联系管理员");
    }
    
    student.setCurrentEnterpriseId(apply.getEnterpriseId());
    student.setInternshipStatus(StudentInternshipStatus.IN_PROGRESS.getCode());
    studentMapper.updateById(student);
}
```

### 10.3 已实现的页面联动

1. ✅ **解绑成功后**：前端重新加载"我的实习"页面和申请列表
2. ✅ **确认上岗成功后**：前端重新加载"我的实习"页面和申请列表
3. ✅ **审核通过后**：前端更新申请列表显示

## 十一、总结

### 11.1 核心设计原则

1. **唯一性**：一个学生同时只能有一个"当前实习"
2. **历史保留**：已解绑的申请保留在数据库中，可以查看历史记录
3. **状态联动**：解绑和确认上岗时，自动更新学生状态
4. **数据一致性**：通过事务和状态验证保证数据一致性

### 11.2 关键实现点

1. **解绑时**：更新 `unbind_status`，如果这是当前实习，清空 `current_apply_id`
2. **确认上岗时**：更新 `student_confirm_status`，设置 `current_apply_id`
3. **查询当前实习时**：过滤已解绑的申请
4. **页面显示时**：根据 `current_apply_id` 和 `unbind_status` 判断显示内容

### 11.3 页面联动

- 解绑成功后，重新加载"我的实习"页面和申请列表
- 确认上岗成功后，重新加载"我的实习"页面和申请列表
- 审核通过后，更新申请列表显示

### 11.4 待修复问题

1. **解绑时状态验证**：需要确保申请已经确认上岗（`student_confirm_status = 1`）
2. **确认上岗方法**：需要禁止自主实习调用 `confirmOnboard()` 方法（自主实习审核通过后自动确认）
3. **前端显示**：自主实习审核通过后，不应该显示"确认上岗"按钮

